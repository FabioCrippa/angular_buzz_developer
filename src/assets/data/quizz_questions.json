{
  "title": "Quiz de Front-End Avançado",
  "questions": [
    {
      "id": 1,
      "question": "O que significa HTML?",
      "options": [
        { "id": 1, "name": "HyperText Markup Language", "alias": "a" },
        { "id": 2, "name": "HyperText Machine Language", "alias": "b" },
        { "id": 3, "name": "HyperTool Markup Language", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "HTML significa HyperText Markup Language, a linguagem de marcação usada para estruturar páginas web.",
      "category": "html"
    },
    {
      "id": 2,
      "question": "Qual tag HTML é usada para criar um link?",
      "options": [
        { "id": 1, "name": "<a>", "alias": "a" },
        { "id": 2, "name": "<link>", "alias": "b" },
        { "id": 3, "name": "<href>", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "A tag <a> é usada para criar links em HTML.",
      "category": "html"
    },
    {
      "id": 3,
      "question": "Qual atributo é usado para abrir um link em uma nova aba?",
      "options": [
        { "id": 1, "name": "target='_blank'", "alias": "a" },
        { "id": 2, "name": "rel='new-tab'", "alias": "b" },
        { "id": 3, "name": "open='new'", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "O atributo target='_blank' faz com que o link seja aberto em uma nova aba.",
      "category": "html"
    },
    {
      "id": 4,
      "question": "Qual é a função da tag <meta> no HTML?",
      "options": [
        { "id": 1, "name": "Definir metadados sobre o documento", "alias": "a" },
        { "id": 2, "name": "Adicionar estilos ao documento", "alias": "b" },
        { "id": 3, "name": "Criar links para outros documentos", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "A tag <meta> define metadados como charset, autor e descrição do documento.",
      "category": "html"
    },
    {
      "id": 5,
      "question": "Qual é o propósito do atributo 'alt' em uma tag <img>?",
      "options": [
        { "id": 1, "name": "Definir o texto alternativo para a imagem", "alias": "a" },
        { "id": 2, "name": "Alterar o tamanho da imagem", "alias": "b" },
        { "id": 3, "name": "Definir a URL da imagem", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "O atributo 'alt' fornece uma descrição alternativa para a imagem, importante para acessibilidade.",
      "category": "html"
    },
    {
      "id": 6,
      "question": "Qual é a diferença entre <section> e <div> no HTML5?",
      "options": [
        { "id": 1, "name": "<section> é semântica, enquanto <div> não é", "alias": "a" },
        { "id": 2, "name": "<div> é semântica, enquanto <section> não é", "alias": "b" },
        { "id": 3, "name": "Ambas são semânticas", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "<section> é uma tag semântica usada para dividir o conteúdo em seções temáticas, enquanto <div> é apenas um contêiner genérico.",
      "category": "html"
    },
    {
      "id": 7,
      "question": "Qual é o propósito do atributo 'defer' em uma tag <script>?",
      "options": [
        { "id": 1, "name": "Carregar o script após o HTML ser completamente analisado", "alias": "a" },
        { "id": 2, "name": "Carregar o script antes do HTML ser analisado", "alias": "b" },
        { "id": 3, "name": "Carregar o script de forma síncrona", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "O atributo 'defer' faz com que o script seja executado somente após o HTML ter sido totalmente carregado.",
      "category": "html"
    },
    {
      "id": 8,
      "question": "Qual é o propósito da tag <template> no HTML5?",
      "options": [
        { "id": 1, "name": "Definir conteúdo que não será renderizado até ser usado via JavaScript", "alias": "a" },
        { "id": 2, "name": "Adicionar estilos ao documento", "alias": "b" },
        { "id": 3, "name": "Criar links para outros documentos", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "A tag <template> permite definir blocos de HTML que só serão renderizados quando manipulados via JavaScript.",
      "category": "html"
    },
    {
      "id": 9,
      "question": "Qual é o propósito do atributo 'contenteditable' no HTML?",
      "options": [
        { "id": 1, "name": "Permitir que o conteúdo de um elemento seja editado pelo usuário", "alias": "a" },
        { "id": 2, "name": "Adicionar estilos ao documento", "alias": "b" },
        { "id": 3, "name": "Criar links para outros documentos", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "O atributo 'contenteditable' permite que o usuário edite o conteúdo do elemento diretamente na página.",
      "category": "html"
    },
    {
      "id": 10,
      "question": "Qual é o propósito do atributo 'aria-label' no HTML?",
      "options": [
        { "id": 1, "name": "Melhorar a acessibilidade ao fornecer uma descrição para leitores de tela", "alias": "a" },
        { "id": 2, "name": "Adicionar estilos ao documento", "alias": "b" },
        { "id": 3, "name": "Criar links para outros documentos", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "O atributo 'aria-label' fornece uma descrição acessível para leitores de tela, melhorando a acessibilidade.",
      "category": "html"
    },
    {
      "id": 11,
      "question": "Qual propriedade CSS é usada para alterar a cor do texto?",
      "options": [
        { "id": 1, "name": "color", "alias": "a" },
        { "id": 2, "name": "text-color", "alias": "b" },
        { "id": 3, "name": "font-color", "alias": "c" }
      ],
      "correct": "a",
      "category": "css"
    },
    {
      "id": 12,
      "question": "Qual é o propósito do método 'filter()' em JavaScript?",
      "options": [
        { "id": 1, "name": "Filtrar elementos de um array com base em uma condição", "alias": "a" },
        { "id": 2, "name": "Adicionar elementos a um array", "alias": "b" },
        { "id": 3, "name": "Remover elementos de um array", "alias": "c" }
      ],
      "correct": "a",
      "category": "javascript"
    },
    {
      "id": 13,
      "question": "Qual é o comando para criar um branch no Git?",
      "options": [
        { "id": 1, "name": "git branch <nome>", "alias": "a" },
        { "id": 2, "name": "git create <nome>", "alias": "b" },
        { "id": 3, "name": "git new <nome>", "alias": "c" }
      ],
      "correct": "a",
      "category": "versionamento"
    },
    {
      "id": 14,
      "question": "Qual é o propósito do atributo 'media' em uma tag <link> no CSS?",
      "options": [
        { "id": 1, "name": "Aplicar estilos com base no tipo de dispositivo", "alias": "a" },
        { "id": 2, "name": "Adicionar metadados ao documento", "alias": "b" },
        { "id": 3, "name": "Definir o caminho para o arquivo CSS", "alias": "c" }
      ],
      "correct": "a",
      "category": "responsividade"
    },
    {
      "id": 15,
      "question": "O que é um 'sprint' no Scrum?",
      "options": [
        { "id": 1, "name": "Um período de tempo para completar um conjunto de tarefas", "alias": "a" },
        { "id": 2, "name": "Uma reunião para revisar o progresso do projeto", "alias": "b" },
        { "id": 3, "name": "Um documento que descreve os requisitos do projeto", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },
    {
      "id": 16,
      "question": "Qual é o comando para fazer deploy em um pipeline DevOps?",
      "options": [
        { "id": 1, "name": "dep deploy", "alias": "a" },
        { "id": 2, "name": "git deploy", "alias": "b" },
        { "id": 3, "name": "dep push", "alias": "c" }
      ],
      "correct": "a",
      "category": "devops"
    },
    {
      "id": 17,
      "question": "Qual é o propósito de um certificado SSL em um ambiente criptografado?",
      "options": [
        { "id": 1, "name": "Garantir a comunicação segura entre cliente e servidor", "alias": "a" },
        { "id": 2, "name": "Aumentar a velocidade de carregamento do site", "alias": "b" },
        { "id": 3, "name": "Adicionar estilos ao site", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },
    {
      "id": 18,
      "question": "Qual é o propósito do `ngFor` no Angular?",
      "options": [
        { "id": 1, "name": "Iterar sobre uma lista e renderizar elementos dinamicamente", "alias": "a" },
        { "id": 2, "name": "Condicionalmente renderizar elementos", "alias": "b" },
        { "id": 3, "name": "Definir um serviço global", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 19,
      "question": "Qual é o propósito do `ngModel` no Angular?",
      "options": [
        { "id": 1, "name": "Criar uma ligação bidirecional entre o modelo e a visão", "alias": "a" },
        { "id": 2, "name": "Definir um componente", "alias": "b" },
        { "id": 3, "name": "Configurar rotas", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 20,
      "question": "Qual é o propósito do `ng-content` no Angular?",
      "options": [
        { "id": 1, "name": "Permitir a projeção de conteúdo em componentes", "alias": "a" },
        { "id": 2, "name": "Definir um componente", "alias": "b" },
        { "id": 3, "name": "Configurar rotas", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 21,
      "question": "Qual comando é usado para criar um novo componente no Angular CLI?",
      "options": [
        { "id": 1, "name": "ng generate component", "alias": "a" },
        { "id": 2, "name": "ng create component", "alias": "b" },
        { "id": 3, "name": "ng new component", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 22,
      "question": "Qual é o propósito do arquivo `angular.json` em um projeto Angular?",
      "options": [
        { "id": 1, "name": "Configurar o build e as configurações do projeto", "alias": "a" },
        { "id": 2, "name": "Definir os estilos globais do projeto", "alias": "b" },
        { "id": 3, "name": "Gerenciar dependências do projeto", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 23,
      "question": "Qual decorator é usado para definir um componente no Angular?",
      "options": [
        { "id": 1, "name": "@Component", "alias": "a" },
        { "id": 2, "name": "@NgModule", "alias": "b" },
        { "id": 3, "name": "@Injectable", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 24,
      "question": "Qual é o propósito do `RouterModule` no Angular?",
      "options": [
        { "id": 1, "name": "Configurar rotas no aplicativo", "alias": "a" },
        { "id": 2, "name": "Gerenciar dependências", "alias": "b" },
        { "id": 3, "name": "Definir serviços globais", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 25,
      "question": "Qual é o ciclo de vida do Angular que é chamado após a criação do componente?",
      "options": [
        { "id": 1, "name": "ngOnInit", "alias": "a" },
        { "id": 2, "name": "ngAfterViewInit", "alias": "b" },
        { "id": 3, "name": "ngOnDestroy", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 26,
      "question": "Qual é o propósito do `HttpClientModule` no Angular?",
      "options": [
        { "id": 1, "name": "Realizar requisições HTTP", "alias": "a" },
        { "id": 2, "name": "Gerenciar rotas", "alias": "b" },
        { "id": 3, "name": "Definir componentes", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 27,
      "question": "Qual é o comando para rodar um projeto Angular localmente?",
      "options": [
        { "id": 1, "name": "ng serve", "alias": "a" },
        { "id": 2, "name": "ng start", "alias": "b" },
        { "id": 3, "name": "ng run", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 28,
      "question": "Qual é o propósito do `@Input` no Angular?",
      "options": [
        { "id": 1, "name": "Permitir que um componente receba dados de um componente pai", "alias": "a" },
        { "id": 2, "name": "Enviar dados para um componente filho", "alias": "b" },
        { "id": 3, "name": "Definir um serviço global", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 29,
      "question": "Qual é o propósito do `@Output` no Angular?",
      "options": [
        { "id": 1, "name": "Emitir eventos de um componente filho para o pai", "alias": "a" },
        { "id": 2, "name": "Receber dados de um componente pai", "alias": "b" },
        { "id": 3, "name": "Definir um serviço global", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 30,
      "question": "Qual é o propósito do `ngFor` no Angular?",
      "options": [
        { "id": 1, "name": "Iterar sobre uma lista e renderizar elementos dinamicamente", "alias": "a" },
        { "id": 2, "name": "Condicionalmente renderizar elementos", "alias": "b" },
        { "id": 3, "name": "Definir um serviço global", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 31,
      "question": "Qual é o propósito do `ngIf` no Angular?",
      "options": [
        { "id": 1, "name": "Condicionalmente renderizar elementos", "alias": "a" },
        { "id": 2, "name": "Iterar sobre uma lista", "alias": "b" },
        { "id": 3, "name": "Definir um serviço global", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 32,
      "question": "Qual é o propósito do `@Injectable` no Angular?",
      "options": [
        { "id": 1, "name": "Definir uma classe como um serviço que pode ser injetado", "alias": "a" },
        { "id": 2, "name": "Definir um componente", "alias": "b" },
        { "id": 3, "name": "Configurar rotas", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 33,
      "question": "Qual é o propósito do `ngOnDestroy` no Angular?",
      "options": [
        { "id": 1, "name": "Executar lógica antes de destruir um componente", "alias": "a" },
        { "id": 2, "name": "Inicializar um componente", "alias": "b" },
        { "id": 3, "name": "Configurar rotas", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 34,
      "question": "Qual é o propósito do `@NgModule` no Angular?",
      "options": [
        { "id": 1, "name": "Definir um módulo no Angular", "alias": "a" },
        { "id": 2, "name": "Definir um componente", "alias": "b" },
        { "id": 3, "name": "Configurar rotas", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 35,
      "question": "Qual é o propósito do `ngClass` no Angular?",
      "options": [
        { "id": 1, "name": "Adicionar ou remover classes dinamicamente", "alias": "a" },
        { "id": 2, "name": "Iterar sobre uma lista", "alias": "b" },
        { "id": 3, "name": "Definir um serviço global", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 36,
      "question": "Qual é o propósito do `ngStyle` no Angular?",
      "options": [
        { "id": 1, "name": "Adicionar ou remover estilos dinamicamente", "alias": "a" },
        { "id": 2, "name": "Iterar sobre uma lista", "alias": "b" },
        { "id": 3, "name": "Definir um serviço global", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 37,
      "question": "Qual é o propósito do `async` no Angular?",
      "options": [
        { "id": 1, "name": "Trabalhar com observáveis e promessas de forma assíncrona", "alias": "a" },
        { "id": 2, "name": "Definir um componente", "alias": "b" },
        { "id": 3, "name": "Configurar rotas", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 38,
      "question": "Qual é o propósito do `FormGroup` no Angular?",
      "options": [
        { "id": 1, "name": "Gerenciar um grupo de controles de formulário", "alias": "a" },
        { "id": 2, "name": "Definir um componente", "alias": "b" },
        { "id": 3, "name": "Configurar rotas", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 39,
      "question": "Qual é o propósito do `FormControl` no Angular?",
      "options": [
        { "id": 1, "name": "Gerenciar o estado de um controle de formulário", "alias": "a" },
        { "id": 2, "name": "Definir um componente", "alias": "b" },
        { "id": 3, "name": "Configurar rotas", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 40,
      "question": "Qual é o propósito do `ReactiveFormsModule` no Angular?",
      "options": [
        { "id": 1, "name": "Trabalhar com formulários reativos", "alias": "a" },
        { "id": 2, "name": "Definir um componente", "alias": "b" },
        { "id": 3, "name": "Configurar rotas", "alias": "c" }
      ],
      "correct": "a",
      "category": "angular"
    },
    {
      "id": 41,
      "question": "Qual é a diferença entre `inline`, `block` e `inline-block` no CSS?",
      "options": [
        { "id": 1, "name": "Define como os elementos são renderizados na página", "alias": "a" },
        { "id": 2, "name": "Define a cor do texto", "alias": "b" },
        { "id": 3, "name": "Define o tamanho do elemento", "alias": "c" }
      ],
      "correct": "a",
      "category": "css"
    },
    {
      "id": 42,
      "question": "Explique o conceito de 'hoisting' no JavaScript.",
      "options": [
        { "id": 1, "name": "É o comportamento de mover declarações para o topo do escopo", "alias": "a" },
        { "id": 2, "name": "É o processo de otimização de código", "alias": "b" },
        { "id": 3, "name": "É o método de chamar funções assíncronas", "alias": "c" }
      ],
      "correct": "a",
      "category": "javascript"
    },
    {
      "id": 43,
      "question": "Qual é a diferença entre `let`, `var` e `const` no JavaScript?",
      "options": [
        { "id": 1, "name": "`let` e `const` têm escopo de bloco, enquanto `var` tem escopo de função", "alias": "a" },
        { "id": 2, "name": "`var` e `const` têm escopo global, enquanto `let` tem escopo de bloco", "alias": "b" },
        { "id": 3, "name": "Não há diferença entre eles", "alias": "c" }
      ],
      "correct": "a",
      "category": "javascript"
    },
    {
      "id": 44,
      "question": "O que é o DOM (Document Object Model)?",
      "options": [
        { "id": 1, "name": "É a representação em árvore de um documento HTML ou XML", "alias": "a" },
        { "id": 2, "name": "É o modelo de design de um site", "alias": "b" },
        { "id": 3, "name": "É o método de estilização de elementos", "alias": "c" }
      ],
      "correct": "a",
      "category": "html"
    },
    {
      "id": 45,
      "question": "Qual é a diferença entre `==` e `===` no JavaScript?",
      "options": [
        { "id": 1, "name": "`==` compara valores, enquanto `===` compara valores e tipos", "alias": "a" },
        { "id": 2, "name": "`==` compara valores e tipos, enquanto `===` compara apenas valores", "alias": "b" },
        { "id": 3, "name": "Ambos comparam apenas valores", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "`==` permite coerção de tipos, enquanto `===` é uma comparação estrita.",
      "category": "javascript",
      "interviewTip": "Como explicar na entrevista: Sempre uso '===' (strict equality) porque é mais previsível. O '==' faz coerção de tipos que pode causar bugs sutis. Por exemplo, '0' == false retorna true, mas '0' === false retorna false. Em produção, prefiro ser explícito e evitar comportamentos inesperados."
    },
    {
      "id": 46,
      "question": "O que é o conceito de 'responsividade' no design web?",
      "options": [
        { "id": 1, "name": "É a capacidade de um site se ajustar a diferentes tamanhos de tela", "alias": "a" },
        { "id": 2, "name": "É a velocidade de carregamento de um site", "alias": "b" },
        { "id": 3, "name": "É a capacidade de um site responder a eventos do usuário", "alias": "c" }
      ],
      "correct": "a",
      "category": "responsividade"
    },
    {
      "id": 47,
      "question": "Explique o conceito de 'promises' no JavaScript.",
      "options": [
        { "id": 1, "name": "É um objeto que representa a eventual conclusão ou falha de uma operação assíncrona", "alias": "a" },
        { "id": 2, "name": "É um método para criar funções síncronas", "alias": "b" },
        { "id": 3, "name": "É uma função que retorna valores imediatamente", "alias": "c" }
      ],
      "correct": "a",
      "category": "javascript"
    },
    {
      "id": 48,
      "question": "Qual é o propósito do atributo `viewport` em uma tag `<meta>`?",
      "options": [
        { "id": 1, "name": "Controlar como o conteúdo é exibido em dispositivos móveis", "alias": "a" },
        { "id": 2, "name": "Definir o idioma do documento", "alias": "b" },
        { "id": 3, "name": "Adicionar estilos ao documento", "alias": "c" }
      ],
      "correct": "a",
      "category": "html"
    },
    {
      "id": 49,
      "question": "O que é um 'polyfill' no desenvolvimento web?",
      "options": [
        { "id": 1, "name": "É um código que adiciona suporte a funcionalidades não disponíveis em navegadores antigos", "alias": "a" },
        { "id": 2, "name": "É um método para otimizar o carregamento de páginas", "alias": "b" },
        { "id": 3, "name": "É uma biblioteca para criar animações", "alias": "c" }
      ],
      "correct": "a",
      "category": "javascript"
    },
    {
      "id": 50,
      "question": "Qual é o propósito do `box-sizing` no CSS?",
      "options": [
        { "id": 1, "name": "Controlar como o tamanho total de um elemento é calculado", "alias": "a" },
        { "id": 2, "name": "Definir o espaçamento interno de um elemento", "alias": "b" },
        { "id": 3, "name": "Definir a largura de um elemento", "alias": "c" }
      ],
      "correct": "a",
      "category": "css"
    },
    {
      "id": 51,
      "question": "Qual é o propósito da tag <header> no HTML5?",
      "options": [
        { "id": 1, "name": "Definir o cabeçalho de uma página ou seção", "alias": "a" },
        { "id": 2, "name": "Adicionar um rodapé à página", "alias": "b" },
        { "id": 3, "name": "Criar um link para outro documento", "alias": "c" }
      ],
      "correct": "a",
      "category": "html"
    },
    {
      "id": 52,
      "question": "Qual é o propósito da tag <footer> no HTML5?",
      "options": [
        { "id": 1, "name": "Definir o rodapé de uma página ou seção", "alias": "a" },
        { "id": 2, "name": "Adicionar um cabeçalho à página", "alias": "b" },
        { "id": 3, "name": "Criar um link para outro documento", "alias": "c" }
      ],
      "correct": "a",
      "category": "html"
    },
    {
      "id": 53,
      "question": "Qual é o propósito do atributo 'lang' na tag <html>?",
      "options": [
        { "id": 1, "name": "Definir o idioma do documento", "alias": "a" },
        { "id": 2, "name": "Adicionar estilos ao documento", "alias": "b" },
        { "id": 3, "name": "Criar links para outros documentos", "alias": "c" }
      ],
      "correct": "a",
      "category": "html"
    },
    {
      "id": 54,
      "question": "Qual é o propósito do atributo 'charset' na tag <meta>?",
      "options": [
        { "id": 1, "name": "Definir a codificação de caracteres do documento", "alias": "a" },
        { "id": 2, "name": "Adicionar estilos ao documento", "alias": "b" },
        { "id": 3, "name": "Criar links para outros documentos", "alias": "c" }
      ],
      "correct": "a",
      "category": "html"
    },
    {
      "id": 55,
      "question": "Qual é o propósito da tag <aside> no HTML5?",
      "options": [
        { "id": 1, "name": "Definir conteúdo relacionado, como barras laterais", "alias": "a" },
        { "id": 2, "name": "Adicionar um cabeçalho à página", "alias": "b" },
        { "id": 3, "name": "Criar links para outros documentos", "alias": "c" }
      ],
      "correct": "a",
      "category": "html"
    },
    {
      "id": 56,
      "question": "Qual propriedade CSS é usada para alterar o tamanho da fonte?",
      "options": [
        { "id": 1, "name": "font-size", "alias": "a" },
        { "id": 2, "name": "text-size", "alias": "b" },
        { "id": 3, "name": "size", "alias": "c" }
      ],
      "correct": "a",
      "category": "css"
    },
    {
      "id": 57,
      "question": "Qual propriedade CSS é usada para alterar a cor de fundo?",
      "options": [
        { "id": 1, "name": "background-color", "alias": "a" },
        { "id": 2, "name": "color", "alias": "b" },
        { "id": 3, "name": "bg-color", "alias": "c" }
      ],
      "correct": "a",
      "category": "css"
    },
    {
      "id": 58,
      "question": "Qual propriedade CSS é usada para centralizar texto?",
      "options": [
        { "id": 1, "name": "text-align", "alias": "a" },
        { "id": 2, "name": "align", "alias": "b" },
        { "id": 3, "name": "center", "alias": "c" }
      ],
      "correct": "a",
      "category": "css"
    },
      {
        "id": 59,
        "question": "Qual é a diferença entre `let`, `var` e `const` na declaração de variáveis?",
        "options": [
          { "id": 1, "name": "`var` tem escopo de função, `let` e `const` têm escopo de bloco", "alias": "a" },
          { "id": 2, "name": "`const` pode ser redefinido após a sua declaração", "alias": "b" },
          { "id": 3, "name": "`let` e `var` são exatamente iguais", "alias": "c" }
        ],
        "correct": "a",
        "category": "javascript"
      },
      {
        "id": 60,
        "question": "O que é um closure em JavaScript?",
        "options": [
          { "id": 1, "name": "Uma função que encapsula uma variável global", "alias": "a" },
          { "id": 2, "name": "Uma função que pode acessar variáveis de seu escopo léxico mesmo após serem removidas do escopo original", "alias": "b" },
          { "id": 3, "name": "Um erro de compilação em JavaScript", "alias": "c" }
        ],
        "correct": "b",
        "category": "javascript"
      },
      {
        "id": 61,
        "question": "Qual é a diferença entre `==` e `===`?",
        "options": [
          { "id": 1, "name": "`==` compara apenas o valor, enquanto `===` compara valor e tipo", "alias": "a" },
          { "id": 2, "name": "`==` e `===` são equivalentes", "alias": "b" },
          { "id": 3, "name": "`===` permite conversão automática de tipos", "alias": "c" }
        ],
        "correct": "a",
        "category": "javascript"
      },
      {
        "id": 62,
        "question": "O que é o **Event Loop** em JavaScript?",
        "options": [
          { "id": 1, "name": "Um mecanismo que permite a execução assíncrona em JavaScript", "alias": "a" },
          { "id": 2, "name": "Uma estrutura para gerenciar funções síncronas", "alias": "b" },
          { "id": 3, "name": "Um processo que bloqueia a execução do JavaScript", "alias": "c" }
        ],
        "correct": "a",
        "category": "javascript"
      },
      {
        "id": 63,
        "question": "O que é o `this` em JavaScript?",
        "options": [
          { "id": 1, "name": "Uma referência ao contexto de execução atual que pode variar", "alias": "a" },
          { "id": 2, "name": "Um objeto global que nunca muda", "alias": "b" },
          { "id": 3, "name": "Um método de manipulação de DOM", "alias": "c" }
        ],
        "correct": "a",
        "category": "javascript"
      },
      {
        "id": 64,
        "question": "Como funciona a herança baseada em protótipos no JavaScript?",
        "options": [
          { "id": 1, "name": "Objetos podem herdar propriedades diretamente de outros objetos por meio de protótipos", "alias": "a" },
          { "id": 2, "name": "JavaScript não suporta herança", "alias": "b" },
          { "id": 3, "name": "A herança em JavaScript é baseada em classes", "alias": "c" }
        ],
        "correct": "a",
        "category": "javascript"
      },
      {
        "id": 65,
        "question": "Como podemos manipular objetos utilizando **destructuring assignment**?",
        "options": [
          { "id": 1, "name": "Atribuindo valores de propriedades diretamente a variáveis usando uma sintaxe especial", "alias": "a" },
          { "id": 2, "name": "Convertendo objetos em arrays automaticamente", "alias": "b" },
          { "id": 3, "name": "Usando um loop `for` para extrair valores", "alias": "c" }
        ],
        "correct": "a",
        "category": "javascript"
      },
      {
        "id": 66,
        "question": "Explique o conceito de **hoisting** em JavaScript.",
        "options": [
          { "id": 1, "name": "Mover declarações de variáveis e funções para o topo do escopo durante a execução", "alias": "a" },
          { "id": 2, "name": "Ajustar automaticamente o desempenho do código JavaScript", "alias": "b" },
          { "id": 3, "name": "Criar um novo escopo para cada variável", "alias": "c" }
        ],
        "correct": "a",
        "category": "javascript"
      },
      {
        "id": 67,
        "question": "O que são **Promises** em JavaScript?",
        "options": [
          { "id": 1, "name": "Uma estrutura para gerenciar código assíncrono", "alias": "a" },
          { "id": 2, "name": "Uma forma de definir variáveis imutáveis", "alias": "b" },
          { "id": 3, "name": "Um loop de repetição especial", "alias": "c" }
        ],
        "correct": "a",
        "category": "javascript"
      },
      {
        "id": 68,
        "question": "O que acontece quando usamos `setTimeout` com um valor de 0ms?",
        "options": [
          { "id": 1, "name": "A função é executada imediatamente", "alias": "a" },
          { "id": 2, "name": "A função é colocada na fila de execução e executada após o Event Loop concluir outras tarefas", "alias": "b" },
          { "id": 3, "name": "O JavaScript pausa a execução até que a função seja chamada", "alias": "c" }
        ],
        "correct": "b",
        "category": "javascript"
      },
      {
        "id": 69,
        "question": "O que é versionamento de código?",
        "options": [
          { "id": 1, "name": "Um processo para acompanhar e registrar alterações no código-fonte", "alias": "a" },
          { "id": 2, "name": "Uma técnica para compactar arquivos de código", "alias": "b" },
          { "id": 3, "name": "Um método de criptografia para proteger código-fonte", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },
      {
        "id": 70,
        "question": "Qual a diferença entre versionamento centralizado e distribuído?",
        "options": [
          { "id": 1, "name": "No centralizado, há um único repositório central; no distribuído, cada usuário tem uma cópia completa", "alias": "a" },
          { "id": 2, "name": "No distribuído, os arquivos são armazenados localmente sem necessidade de um servidor", "alias": "b" },
          { "id": 3, "name": "No centralizado, cada usuário tem uma cópia completa do repositório", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },
      {
        "id": 71,
        "question": "O que é um commit no controle de versão?",
        "options": [
          { "id": 1, "name": "Uma alteração registrada no histórico do repositório", "alias": "a" },
          { "id": 2, "name": "Um backup automático do código-fonte", "alias": "b" },
          { "id": 3, "name": "Um comando para excluir arquivos do repositório", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },
      {
        "id": 72,
        "question": "Como funcionam os branches em sistemas de versionamento como Git?",
        "options": [
          { "id": 1, "name": "Permitem trabalhar em diferentes versões do código sem afetar a principal", "alias": "a" },
          { "id": 2, "name": "São cópias permanentes do código que não podem ser alteradas", "alias": "b" },
          { "id": 3, "name": "São arquivos temporários que desaparecem após o commit", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },
      {
        "id": 73,
        "question": "O que é um merge no Git?",
        "options": [
          { "id": 1, "name": "A junção de alterações de diferentes branches em um único branch", "alias": "a" },
          { "id": 2, "name": "Um comando para excluir branches antigos", "alias": "b" },
          { "id": 3, "name": "Uma técnica para compactar commits", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },
      {
        "id": 74,
        "question": "Por que mensagens de commit bem escritas são importantes?",
        "options": [
          { "id": 1, "name": "Facilitam o entendimento das alterações feitas no código", "alias": "a" },
          { "id": 2, "name": "Ajudam a reduzir o tamanho do repositório", "alias": "b" },
          { "id": 3, "name": "São obrigatórias para realizar um commit", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },
      {
        "id": 75,
        "question": "O que são tags em sistemas de versionamento?",
        "options": [
          { "id": 1, "name": "Marcadores usados para identificar versões específicas do código", "alias": "a" },
          { "id": 2, "name": "Arquivos temporários gerados pelo sistema de controle de versão", "alias": "b" },
          { "id": 3, "name": "Comentários adicionados ao código para facilitar a leitura", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },
      {
        "id": 76,
        "question": "Como o versionamento de código facilita o trabalho colaborativo?",
        "options": [
          { "id": 1, "name": "Permite que vários desenvolvedores trabalhem simultaneamente sem conflitos", "alias": "a" },
          { "id": 2, "name": "Impede que diferentes usuários acessem o mesmo código", "alias": "b" },
          { "id": 3, "name": "Remove automaticamente código duplicado", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },
      {
        "id": 77,
        "question": "O que é um repositório remoto?",
        "options": [
          { "id": 1, "name": "Um repositório armazenado em um servidor acessível por vários usuários", "alias": "a" },
          { "id": 2, "name": "Uma cópia local do código-fonte", "alias": "b" },
          { "id": 3, "name": "Um backup automático do código", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },
      {
        "id": 78,
        "question": "Quais são as melhores práticas para evitar conflitos ao trabalhar com versionamento?",
        "options": [
          { "id": 1, "name": "Realizar commits frequentes e manter o código atualizado com o repositório remoto", "alias": "a" },
          { "id": 2, "name": "Evitar o uso de branches", "alias": "b" },
          { "id": 3, "name": "Nunca realizar merges", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },
      {
        "id": 79,
        "question": "O que é CSS e qual sua função?",
        "options": [
          { "id": 1, "name": "Uma linguagem de marcação para estruturar páginas web", "alias": "a" },
          { "id": 2, "name": "Uma linguagem de estilo usada para definir a aparência de elementos HTML", "alias": "b" },
          { "id": 3, "name": "Um framework para desenvolvimento de aplicações web", "alias": "c" }
        ],
        "correct": "b",
        "category": "css"
      },
      {
        "id": 80,
        "question": "Qual a diferença entre CSS inline, interno e externo?",
        "options": [
          { "id": 1, "name": "CSS inline é aplicado diretamente no elemento, interno dentro da tag `<style>` e externo em um arquivo separado", "alias": "a" },
          { "id": 2, "name": "CSS interno e externo são iguais, apenas o inline é diferente", "alias": "b" },
          { "id": 3, "name": "CSS externo é usado apenas para JavaScript", "alias": "c" }
        ],
        "correct": "a",
        "category": "css"
      },
      {
        "id": 81,
        "question": "O que é a especificidade no CSS?",
        "options": [
          { "id": 1, "name": "A prioridade que um seletor tem sobre outro ao aplicar estilos", "alias": "a" },
          { "id": 2, "name": "Um método para organizar arquivos CSS", "alias": "b" },
          { "id": 3, "name": "Uma propriedade que define a cor do texto", "alias": "c" }
        ],
        "correct": "a",
        "category": "css"
      },
      {
        "id": 82,
        "question": "O que é um pseudo-elemento no CSS?",
        "options": [
          { "id": 1, "name": "Um elemento HTML que não pode ser estilizado", "alias": "a" },
          { "id": 2, "name": "Uma palavra-chave que permite estilizar partes específicas de um elemento", "alias": "b" },
          { "id": 3, "name": "Uma propriedade usada para definir animações", "alias": "c" }
        ],
        "correct": "b",
        "category": "css"
      },
      {
        "id": 83,
        "question": "Qual é a função do `z-index` no CSS?",
        "options": [
          { "id": 1, "name": "Definir a ordem de empilhamento dos elementos na página", "alias": "a" },
          { "id": 2, "name": "Alterar a opacidade dos elementos", "alias": "b" },
          { "id": 3, "name": "Definir a largura máxima de um elemento", "alias": "c" }
        ],
        "correct": "a",
        "category": "css"
      },
      {
        "id": 84,
        "question": "O que é o modelo de caixa (box model) no CSS?",
        "options": [
          { "id": 1, "name": "Uma estrutura que define como os elementos HTML são renderizados na página", "alias": "a" },
          { "id": 2, "name": "Um método para criar animações", "alias": "b" },
          { "id": 3, "name": "Uma propriedade usada para definir sombras", "alias": "c" }
        ],
        "correct": "a",
        "category": "css"
      },
      {
        "id": 85,
        "question": "Qual a diferença entre `relative`, `absolute` e `fixed` no posicionamento CSS?",
        "options": [
          { "id": 1, "name": "`relative` posiciona em relação ao local original, `absolute` em relação ao elemento pai e `fixed` em relação à janela", "alias": "a" },
          { "id": 2, "name": "Todos os três posicionam os elementos da mesma forma", "alias": "b" },
          { "id": 3, "name": "`fixed` e `absolute` são iguais, apenas `relative` é diferente", "alias": "c" }
        ],
        "correct": "a",
        "category": "css"
      },
      {
        "id": 86,
        "question": "O que são media queries no CSS?",
        "options": [
          { "id": 1, "name": "Regras que permitem aplicar estilos diferentes dependendo do tamanho da tela", "alias": "a" },
          { "id": 2, "name": "Uma técnica para otimizar imagens", "alias": "b" },
          { "id": 3, "name": "Um método para criar animações CSS", "alias": "c" }
        ],
        "correct": "a",
        "category": "css"
      },
      {
        "id": 87,
        "question": "Qual a função da propriedade `flex-grow` no Flexbox?",
        "options": [
          { "id": 1, "name": "Define a capacidade de um item crescer dentro do contêiner flexível", "alias": "a" },
          { "id": 2, "name": "Define a altura máxima de um elemento", "alias": "b" },
          { "id": 3, "name": "Define a opacidade do elemento", "alias": "c" }
        ],
        "correct": "a",
        "category": "css"
      },
      {
        "id": 88,
        "question": "O que é a propriedade `grid-template-columns` no CSS Grid?",
        "options": [
          { "id": 1, "name": "Define o número e tamanho das colunas em um layout de grade", "alias": "a" },
          { "id": 2, "name": "Define a cor de fundo das colunas", "alias": "b" },
          { "id": 3, "name": "Define a altura das linhas", "alias": "c" }
        ],
        "correct": "a",
        "category": "css"
      },  
      {
        "id": 89,
        "question": "O que é um sistema de controle de versão?",
        "options": [
          { "id": 1, "name": "Uma ferramenta que gerencia e registra alterações no código-fonte", "alias": "a" },
          { "id": 2, "name": "Um software para testar código antes da implantação", "alias": "b" },
          { "id": 3, "name": "Um método para compactar arquivos de código", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },
      {
        "id": 90,
        "question": "Qual a função do comando `git clone`?",
        "options": [
          { "id": 1, "name": "Criar um novo repositório local a partir de um remoto", "alias": "a" },
          { "id": 2, "name": "Excluir um repositório remoto", "alias": "b" },
          { "id": 3, "name": "Mesclar alterações entre branches", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },
      {
        "id": 91,
        "question": "O que é um rebase no Git?",
        "options": [
          { "id": 1, "name": "Uma técnica para reescrever o histórico de commits", "alias": "a" },
          { "id": 2, "name": "Um comando para excluir branches antigos", "alias": "b" },
          { "id": 3, "name": "Uma forma de compactar arquivos no repositório", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },
      {
        "id": 92,
        "question": "Qual a diferença entre `git pull` e `git fetch`?",
        "options": [
          { "id": 1, "name": "`git pull` baixa e aplica as alterações, enquanto `git fetch` apenas baixa sem aplicar", "alias": "a" },
          { "id": 2, "name": "Ambos os comandos fazem exatamente a mesma coisa", "alias": "b" },
          { "id": 3, "name": "`git fetch` exclui arquivos antigos do repositório", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },
      {
        "id": 93,
        "question": "O que é um commit revertido?",
        "options": [
          { "id": 1, "name": "Um commit que desfaz alterações anteriores sem remover o histórico", "alias": "a" },
          { "id": 2, "name": "Um commit que exclui permanentemente arquivos do repositório", "alias": "b" },
          { "id": 3, "name": "Um commit que mescla alterações de diferentes branches", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },
      {
        "id": 94,
        "question": "Qual a função do arquivo `.gitignore`?",
        "options": [
          { "id": 1, "name": "Definir quais arquivos devem ser ignorados pelo Git", "alias": "a" },
          { "id": 2, "name": "Excluir arquivos do repositório remoto", "alias": "b" },
          { "id": 3, "name": "Criar um backup automático do código", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },
      {
        "id": 95,
        "question": "O que acontece quando usamos `git stash`?",
        "options": [
          { "id": 1, "name": "Salva temporariamente alterações não commitadas para retomá-las depois", "alias": "a" },
          { "id": 2, "name": "Exclui todas as alterações não commitadas", "alias": "b" },
          { "id": 3, "name": "Cria um novo branch automaticamente", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },
      {
        "id": 96,
        "question": "Qual a função do comando `git diff`?",
        "options": [
          { "id": 1, "name": "Exibir diferenças entre versões do código", "alias": "a" },
          { "id": 2, "name": "Excluir arquivos do repositório", "alias": "b" },
          { "id": 3, "name": "Criar um novo commit automaticamente", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },
      {
        "id": 97,
        "question": "O que é um fork em sistemas de versionamento?",
        "options": [
          { "id": 1, "name": "Uma cópia independente de um repositório remoto", "alias": "a" },
          { "id": 2, "name": "Um comando para excluir branches antigos", "alias": "b" },
          { "id": 3, "name": "Uma técnica para compactar commits", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },
      {
        "id": 98,
        "question": "Qual a importância do versionamento de código em projetos colaborativos?",
        "options": [
          { "id": 1, "name": "Facilita o rastreamento de alterações e colaboração entre desenvolvedores", "alias": "a" },
          { "id": 2, "name": "Impede que diferentes usuários acessem o mesmo código", "alias": "b" },
          { "id": 3, "name": "Remove automaticamente código duplicado", "alias": "c" }
        ],
        "correct": "a",
        "category": "versionamento"
      },     
      {
        "id": 99,
        "question": "O que é responsividade em desenvolvimento web?",
        "options": [
          { "id": 1, "name": "A capacidade de um site se adaptar a diferentes tamanhos de tela", "alias": "a" },
          { "id": 2, "name": "Um método para aumentar a velocidade de carregamento", "alias": "b" },
          { "id": 3, "name": "Uma técnica para criar animações interativas", "alias": "c" }
        ],
        "correct": "a",
        "category": "responsividade"
      },
      {
        "id": 100,
        "question": "Qual a função das media queries no CSS?",
        "options": [
          { "id": 1, "name": "Permitir a aplicação de estilos diferentes com base no tamanho da tela", "alias": "a" },
          { "id": 2, "name": "Criar animações CSS avançadas", "alias": "b" },
          { "id": 3, "name": "Definir a estrutura HTML de uma página", "alias": "c" }
        ],
        "correct": "a",
        "category": "responsividade"
      },
      {
        "id": 101,
        "question": "O que significa o conceito de 'mobile-first'?",
        "options": [
          { "id": 1, "name": "Desenvolver primeiro para dispositivos móveis e depois para telas maiores", "alias": "a" },
          { "id": 2, "name": "Criar sites exclusivamente para dispositivos móveis", "alias": "b" },
          { "id": 3, "name": "Priorizar animações em dispositivos móveis", "alias": "c" }
        ],
        "correct": "a",
        "category": "responsividade"
      },
      {
        "id": 102,
        "question": "Qual propriedade CSS pode ser usada para tornar imagens responsivas?",
        "options": [
          { "id": 1, "name": "`max-width: 100%`", "alias": "a" },
          { "id": 2, "name": "`position: absolute`", "alias": "b" },
          { "id": 3, "name": "`display: block`", "alias": "c" }
        ],
        "correct": "a",
        "category": "responsividade"
      },
      {
        "id": 103,
        "question": "O que é um layout fluido?",
        "options": [
          { "id": 1, "name": "Um layout que se ajusta dinamicamente ao tamanho da tela", "alias": "a" },
          { "id": 2, "name": "Um layout fixo que não muda de tamanho", "alias": "b" },
          { "id": 3, "name": "Um layout baseado apenas em pixels", "alias": "c" }
        ],
        "correct": "a",
        "category": "responsividade"
      },
      {
        "id": 104,
        "question": "Qual unidade de medida é mais recomendada para fontes em sites responsivos?",
        "options": [
          { "id": 1, "name": "rem", "alias": "a" },
          { "id": 2, "name": "px", "alias": "b" },
          { "id": 3, "name": "cm", "alias": "c" }
        ],
        "correct": "a",
        "category": "responsividade"
      },
      {
        "id": 105,
        "question": "O que é viewport no contexto de responsividade?",
        "options": [
          { "id": 1, "name": "A área visível de um site em um dispositivo", "alias": "a" },
          { "id": 2, "name": "Um elemento HTML usado para criar menus", "alias": "b" },
          { "id": 3, "name": "Uma propriedade CSS para definir cores", "alias": "c" }
        ],
        "correct": "a",
        "category": "responsividade"
      },
      {
        "id": 106,
        "question": "Qual meta tag é essencial para tornar um site responsivo?",
        "options": [
          { "id": 1, "name": "`<meta name='viewport' content='width=device-width, initial-scale=1.0'>`", "alias": "a" },
          { "id": 2, "name": "`<meta name='responsive' content='true'>`", "alias": "b" },
          { "id": 3, "name": "`<meta name='mobile' content='yes'>`", "alias": "c" }
        ],
        "correct": "a",
        "category": "responsividade"
      },
      {
        "id": 107,
        "question": "O que é um breakpoint em design responsivo?",
        "options": [
          { "id": 1, "name": "Um ponto onde o layout muda com base no tamanho da tela", "alias": "a" },
          { "id": 2, "name": "Um erro de código que impede a responsividade", "alias": "b" },
          { "id": 3, "name": "Uma técnica para criar animações CSS", "alias": "c" }
        ],
        "correct": "a",
        "category": "responsividade"
      },
      {
        "id": 108,
        "question": "Qual técnica pode ser usada para esconder elementos em telas menores?",
        "options": [
          { "id": 1, "name": "`display: none;`", "alias": "a" },
          { "id": 2, "name": "`visibility: hidden;`", "alias": "b" },
          { "id": 3, "name": "`opacity: 0;`", "alias": "c" }
        ],
        "correct": "a",
        "category": "responsividade"
      },      
      {
        "id": 109,
        "question": "O que é um layout adaptativo?",
        "options": [
          { "id": 1, "name": "Um layout que usa pontos de quebra para se ajustar a diferentes dispositivos", "alias": "a" },
          { "id": 2, "name": "Um layout fixo que não muda de tamanho", "alias": "b" },
          { "id": 3, "name": "Um layout baseado apenas em pixels", "alias": "c" }
        ],
        "correct": "a",
        "category": "responsividade"
      },
      {
        "id": 110,
        "question": "Qual a diferença entre design responsivo e design adaptativo?",
        "options": [
          { "id": 1, "name": "O design responsivo usa layouts fluidos, enquanto o adaptativo usa pontos de quebra fixos", "alias": "a" },
          { "id": 2, "name": "Ambos são exatamente iguais", "alias": "b" },
          { "id": 3, "name": "O design adaptativo é usado apenas para aplicativos móveis", "alias": "c" }
        ],
        "correct": "a",
        "category": "responsividade"
      },
      {
        "id": 111,
        "question": "Como o Flexbox pode ajudar na responsividade?",
        "options": [
          { "id": 1, "name": "Permite organizar elementos de forma flexível e adaptável ao tamanho da tela", "alias": "a" },
          { "id": 2, "name": "Cria animações responsivas automaticamente", "alias": "b" },
          { "id": 3, "name": "Define a largura fixa dos elementos", "alias": "c" }
        ],
        "correct": "a",
        "category": "responsividade"
    },
    {
      "id": 112,
      "question": "O que é a propriedade `object-fit` no CSS?",
      "options": [
        { "id": 1, "name": "Define como uma imagem deve se ajustar ao seu contêiner", "alias": "a" },
        { "id": 2, "name": "Define a opacidade de um elemento", "alias": "b" },
        { "id": 3, "name": "Cria sombras em elementos", "alias": "c" }
      ],
      "correct": "a",
      "category": "responsividade"
    },
    {
      "id": 113,
      "question": "Qual a importância do `min-width` e `max-width` na responsividade?",
      "options": [
        { "id": 1, "name": "Permitem definir limites mínimos e máximos para o tamanho de um elemento", "alias": "a" },
        { "id": 2, "name": "Aumentam a velocidade de carregamento da página", "alias": "b" },
        { "id": 3, "name": "Criam animações automáticas", "alias": "c" }
      ],
      "correct": "a",
      "category": "responsividade"
    },
    {
      "id": 114,
      "question": "Como o Grid Layout pode ser usado para criar layouts responsivos?",
      "options": [
        { "id": 1, "name": "Permite definir áreas flexíveis que se ajustam ao tamanho da tela", "alias": "a" },
        { "id": 2, "name": "Cria animações responsivas automaticamente", "alias": "b" },
        { "id": 3, "name": "Define a largura fixa dos elementos", "alias": "c" }
      ],
      "correct": "a",
      "category": "responsividade"
    },
    {
      "id": 115,
      "question": "O que é a técnica de 'lazy loading' e como ela impacta a responsividade?",
      "options": [
        { "id": 1, "name": "Carrega imagens e conteúdos apenas quando necessários, melhorando o desempenho", "alias": "a" },
        { "id": 2, "name": "Cria animações responsivas", "alias": "b" },
        { "id": 3, "name": "Aumenta o tamanho das imagens para telas maiores", "alias": "c" }
      ],
      "correct": "a",
      "category": "responsividade"
    },
    {
      "id": 116,
      "question": "O que é Scrum?",
      "options": [
        { "id": 1, "name": "Um framework ágil para gerenciamento de projetos", "alias": "a" },
        { "id": 2, "name": "Um software de desenvolvimento de código", "alias": "b" },
        { "id": 3, "name": "Um método de teste automatizado", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },
    {
      "id": 117,
      "question": "Quem é responsável por maximizar o valor do produto no Scrum?",
      "options": [
        { "id": 1, "name": "O Scrum Master", "alias": "a" },
        { "id": 2, "name": "O Product Owner", "alias": "b" },
        { "id": 3, "name": "O Time de Desenvolvimento", "alias": "c" }
      ],
      "correct": "b",
      "category": "scrum"
    },
    {
      "id": 118,
      "question": "O que é um Sprint no Scrum?",
      "options": [
        { "id": 1, "name": "Um período de tempo fixo para desenvolver um incremento do produto", "alias": "a" },
        { "id": 2, "name": "Uma reunião diária para discutir o progresso", "alias": "b" },
        { "id": 3, "name": "Um documento que define os requisitos do projeto", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },
    {
      "id": 119,
      "question": "Qual é a função do Scrum Master?",
      "options": [
        { "id": 1, "name": "Garantir que o Scrum seja compreendido e aplicado corretamente", "alias": "a" },
        { "id": 2, "name": "Definir os requisitos do produto", "alias": "b" },
        { "id": 3, "name": "Codificar e testar o software", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },
    {
      "id": 120,
      "question": "O que é um Product Backlog?",
      "options": [
        { "id": 1, "name": "Uma lista priorizada de funcionalidades e requisitos do produto", "alias": "a" },
        { "id": 2, "name": "Um documento de planejamento financeiro", "alias": "b" },
        { "id": 3, "name": "Uma ferramenta de controle de qualidade", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },
    {
      "id": 121,
      "question": "O que acontece na Sprint Planning?",
      "options": [
        { "id": 1, "name": "O Time Scrum define quais itens do Product Backlog serão trabalhados na Sprint", "alias": "a" },
        { "id": 2, "name": "O Scrum Master revisa o código do projeto", "alias": "b" },
        { "id": 3, "name": "Os desenvolvedores apresentam o produto final ao cliente", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },
    {
      "id": 122,
      "question": "Qual é o objetivo da Daily Scrum?",
      "options": [
        { "id": 1, "name": "Sincronizar as atividades do Time de Desenvolvimento e identificar impedimentos", "alias": "a" },
        { "id": 2, "name": "Definir novos requisitos para o produto", "alias": "b" },
        { "id": 3, "name": "Encerrar a Sprint e revisar os resultados", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },
    {
      "id": 123,
      "question": "O que é um Sprint Backlog?",
      "options": [
        { "id": 1, "name": "Uma lista de tarefas selecionadas para serem desenvolvidas na Sprint", "alias": "a" },
        { "id": 2, "name": "Um relatório de progresso do projeto", "alias": "b" },
        { "id": 3, "name": "Uma ferramenta de controle de qualidade", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },
    {
      "id": 124,
      "question": "O que acontece na Sprint Review?",
      "options": [
        { "id": 1, "name": "O Time Scrum apresenta o incremento do produto para os stakeholders", "alias": "a" },
        { "id": 2, "name": "Os desenvolvedores revisam o código do projeto", "alias": "b" },
        { "id": 3, "name": "O Scrum Master define os próximos passos do projeto", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },
    {
      "id": 125,
      "question": "Qual é o objetivo da Sprint Retrospective?",
      "options": [
        { "id": 1, "name": "Identificar melhorias no processo e aumentar a eficiência do Time Scrum", "alias": "a" },
        { "id": 2, "name": "Definir novos requisitos para o produto", "alias": "b" },
        { "id": 3, "name": "Encerrar oficialmente o projeto", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },      
    {
      "id": 126,
      "question": "O que é um artefato no Scrum?",
      "options": [
        { "id": 1, "name": "Um elemento essencial para transparência e inspeção no processo Scrum", "alias": "a" },
        { "id": 2, "name": "Um documento de requisitos do projeto", "alias": "b" },
        { "id": 3, "name": "Uma ferramenta de controle de qualidade", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },
    {
      "id": 127,
      "question": "Qual é a função do Incremento no Scrum?",
      "options": [
        { "id": 1, "name": "Representar a soma de todos os itens do Product Backlog concluídos durante a Sprint", "alias": "a" },
        { "id": 2, "name": "Definir os requisitos do produto", "alias": "b" },
        { "id": 3, "name": "Criar um novo Sprint Backlog", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },
    {
      "id": 128,
      "question": "O que é um Definition of Done (DoD) no Scrum?",
      "options": [
        { "id": 1, "name": "Um conjunto de critérios que define quando um item do backlog está concluído", "alias": "a" },
        { "id": 2, "name": "Uma lista de tarefas pendentes", "alias": "b" },
        { "id": 3, "name": "Um documento de planejamento financeiro", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },
    {
      "id": 129,
      "question": "Qual é o papel do Time de Desenvolvimento no Scrum?",
      "options": [
        { "id": 1, "name": "Criar incrementos de produto potencialmente utilizáveis a cada Sprint", "alias": "a" },
        { "id": 2, "name": "Gerenciar o Product Backlog", "alias": "b" },
        { "id": 3, "name": "Definir os objetivos do projeto", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },
    {
      "id": 130,
      "question": "O que é um Sprint Goal?",
      "options": [
        { "id": 1, "name": "Um objetivo que orienta o trabalho do Time de Desenvolvimento durante a Sprint", "alias": "a" },
        { "id": 2, "name": "Uma lista de tarefas pendentes", "alias": "b" },
        { "id": 3, "name": "Um relatório de progresso do projeto", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },
    {
      "id": 131,
      "question": "Qual é a importância da transparência no Scrum?",
      "options": [
        { "id": 1, "name": "Permitir que todos os envolvidos tenham uma visão clara do progresso e dos desafios do projeto", "alias": "a" },
        { "id": 2, "name": "Garantir que apenas o Scrum Master tenha controle sobre o projeto", "alias": "b" },
        { "id": 3, "name": "Evitar que o Product Owner participe das decisões", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },
    {
      "id": 132,
      "question": "O que é um Burndown Chart no Scrum?",
      "options": [
        { "id": 1, "name": "Um gráfico que mostra o progresso do trabalho restante ao longo do tempo", "alias": "a" },
        { "id": 2, "name": "Uma ferramenta para estimar custos do projeto", "alias": "b" },
        { "id": 3, "name": "Um documento de planejamento estratégico", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },
    {
      "id": 133,
      "question": "Qual é a função do Refinamento do Backlog no Scrum?",
      "options": [
        { "id": 1, "name": "Ajustar e detalhar os itens do Product Backlog para futuras Sprints", "alias": "a" },
        { "id": 2, "name": "Definir os objetivos do projeto", "alias": "b" },
        { "id": 3, "name": "Criar um novo Sprint Backlog", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },
    {
      "id": 134,
      "question": "O que significa inspeção e adaptação no Scrum?",
      "options": [
        { "id": 1, "name": "Revisar continuamente o progresso e ajustar o processo conforme necessário", "alias": "a" },
        { "id": 2, "name": "Definir um plano fixo sem possibilidade de mudanças", "alias": "b" },
        { "id": 3, "name": "Criar um novo Product Backlog", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },
    {
      "id": 135,
      "question": "Qual é a importância da auto-organização no Time Scrum?",
      "options": [
        { "id": 1, "name": "Permitir que o Time de Desenvolvimento tome decisões sobre como realizar o trabalho", "alias": "a" },
        { "id": 2, "name": "Garantir que o Scrum Master controle todas as tarefas", "alias": "b" },
        { "id": 3, "name": "Evitar que o Product Owner participe das decisões", "alias": "c" }
      ],
      "correct": "a",
      "category": "scrum"
    },      
    {
      "id": 136,
      "question": "O que é DevOps?",
      "options": [
        { "id": 1, "name": "Uma cultura e conjunto de práticas que integram desenvolvimento e operações", "alias": "a" },
        { "id": 2, "name": "Um framework para desenvolvimento de software", "alias": "b" },
        { "id": 3, "name": "Uma linguagem de programação para automação", "alias": "c" }
      ],
      "correct": "a",
      "category": "devops"
    },
    {
      "id": 137,
      "question": "Quais são os principais benefícios do DevOps?",
      "options": [
        { "id": 1, "name": "Entrega contínua, maior colaboração e automação de processos", "alias": "a" },
        { "id": 2, "name": "Redução da necessidade de testes", "alias": "b" },
        { "id": 3, "name": "Eliminação da necessidade de infraestrutura", "alias": "c" }
      ],
      "correct": "a",
      "category": "devops"
    },
    {
      "id": 138,
      "question": "O que é integração contínua (CI) no DevOps?",
      "options": [
        { "id": 1, "name": "Um processo de automação para integrar código frequentemente", "alias": "a" },
        { "id": 2, "name": "Uma técnica para testar código manualmente", "alias": "b" },
        { "id": 3, "name": "Um método para criar bancos de dados", "alias": "c" }
      ],
      "correct": "a",
      "category": "devops"
    },
    {
      "id": 139,
      "question": "O que é entrega contínua (CD) no DevOps?",
      "options": [
        { "id": 1, "name": "Automatização do processo de entrega de software para produção", "alias": "a" },
        { "id": 2, "name": "Uma técnica para criar interfaces gráficas", "alias": "b" },
        { "id": 3, "name": "Um método para gerenciar bancos de dados", "alias": "c" }
      ],
      "correct": "a",
      "category": "devops"
    },
    {
      "id": 140,
      "question": "Qual é a importância da automação no DevOps?",
      "options": [
        { "id": 1, "name": "Reduz erros humanos e melhora a eficiência dos processos", "alias": "a" },
        { "id": 2, "name": "Elimina a necessidade de testes", "alias": "b" },
        { "id": 3, "name": "Substitui completamente os desenvolvedores", "alias": "c" }
      ],
      "correct": "a",
      "category": "devops"
    },
    {
      "id": 141,
      "question": "O que é um pipeline de CI/CD?",
      "options": [
        { "id": 1, "name": "Um conjunto de etapas automatizadas para integração e entrega contínua", "alias": "a" },
        { "id": 2, "name": "Um método para criar interfaces de usuário", "alias": "b" },
        { "id": 3, "name": "Uma técnica para gerenciar bancos de dados", "alias": "c" }
      ],
      "correct": "a",
      "category": "devops"
    },
    {
      "id": 142,
      "question": "Quais são algumas ferramentas populares usadas em DevOps?",
      "options": [
        { "id": 1, "name": "Jenkins, Docker, Kubernetes, Ansible e Git", "alias": "a" },
        { "id": 2, "name": "Photoshop, Illustrator e After Effects", "alias": "b" },
        { "id": 3, "name": "Excel, Word e PowerPoint", "alias": "c" }
      ],
      "correct": "a",
      "category": "devops"
    },
    {
      "id": 143,
      "question": "O que é monitoramento no DevOps?",
      "options": [
        { "id": 1, "name": "A prática de acompanhar o desempenho e a saúde dos sistemas", "alias": "a" },
        { "id": 2, "name": "Um método para criar relatórios financeiros", "alias": "b" },
        { "id": 3, "name": "Uma técnica para gerenciar bancos de dados", "alias": "c" }
      ],
      "correct": "a",
      "category": "devops"
    },
    {
      "id": 144,
      "question": "O que é infraestrutura como código (IaC)?",
      "options": [
        { "id": 1, "name": "Uma abordagem para gerenciar infraestrutura por meio de código", "alias": "a" },
        { "id": 2, "name": "Um método para criar interfaces gráficas", "alias": "b" },
        { "id": 3, "name": "Uma técnica para gerenciar bancos de dados", "alias": "c" }
      ],
      "correct": "a",
      "category": "devops"
    },
    {
      "id": 145,
      "question": "Qual é o papel do DevOps na segurança?",
      "options": [
        { "id": 1, "name": "Integrar práticas de segurança ao longo do ciclo de desenvolvimento", "alias": "a" },
        { "id": 2, "name": "Eliminar a necessidade de testes de segurança", "alias": "b" },
        { "id": 3, "name": "Substituir completamente os analistas de segurança", "alias": "c" }
      ],
      "correct": "a",
      "category": "devops"
    },      
    {
      "id": 146,
      "question": "O que é criptografia?",
      "options": [
        { "id": 1, "name": "Um método de codificação de informações para garantir sua segurança", "alias": "a" },
        { "id": 2, "name": "Uma técnica de armazenamento de dados", "alias": "b" },
        { "id": 3, "name": "Um processo de compressão de arquivos", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },
    {
      "id": 147,
      "question": "Qual é o principal objetivo da criptografia?",
      "options": [
        { "id": 1, "name": "Garantir a privacidade e integridade das informações", "alias": "a" },
        { "id": 2, "name": "Reduzir o tamanho dos arquivos", "alias": "b" },
        { "id": 3, "name": "Acelerar a transmissão de dados", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },
    {
      "id": 148,
      "question": "Qual dos seguintes termos está relacionado à criptografia simétrica?",
      "options": [
        { "id": 1, "name": "Uma única chave usada para criptografar e descriptografar", "alias": "a" },
        { "id": 2, "name": "Chave pública e chave privada", "alias": "b" },
        { "id": 3, "name": "Autenticação baseada em assinatura digital", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },
    {
      "id": 149,
      "question": "Qual é a principal característica da criptografia assimétrica?",
      "options": [
        { "id": 1, "name": "Usa uma chave pública para criptografar e uma chave privada para descriptografar", "alias": "a" },
        { "id": 2, "name": "Usa a mesma chave para criptografar e descriptografar os dados", "alias": "b" },
        { "id": 3, "name": "Não necessita de chave para criptografar os dados", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },
    {
      "id": 150,
      "question": "Qual é a função principal de um protocolo criptográfico?",
      "options": [
        { "id": 1, "name": "Estabelecer regras e métodos para realizar a criptografia e garantir a segurança das comunicações", "alias": "a" },
        { "id": 2, "name": "Gerenciar a quantidade de dados transmitidos", "alias": "b" },
        { "id": 3, "name": "Controlar os erros durante a comunicação de dados", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },
    {
      "id": 151,
      "question": "O que é uma chave de criptografia?",
      "options": [
        { "id": 1, "name": "Uma sequência de caracteres usada para criptografar ou descriptografar dados", "alias": "a" },
        { "id": 2, "name": "Um código que permite a compactação dos dados", "alias": "b" },
        { "id": 3, "name": "Um identificador de usuários no sistema", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },
    {
      "id": 152,
      "question": "Qual é o principal protocolo criptográfico usado em redes de comunicação seguras?",
      "options": [
        { "id": 1, "name": "SSL/TLS (Secure Sockets Layer / Transport Layer Security)", "alias": "a" },
        { "id": 2, "name": "SMTP (Simple Mail Transfer Protocol)", "alias": "b" },
        { "id": 3, "name": "HTTP (HyperText Transfer Protocol)", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },
    {
      "id": 153,
      "question": "O que é criptografia de ponta a ponta?",
      "options": [
        { "id": 1, "name": "Um método que garante que apenas o remetente e o destinatário possam acessar os dados", "alias": "a" },
        { "id": 2, "name": "Uma técnica para compactar arquivos antes da transmissão", "alias": "b" },
        { "id": 3, "name": "Um protocolo para acelerar a comunicação de dados", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },
    {
      "id": 154,
      "question": "O que é um ataque de força bruta na criptografia?",
      "options": [
        { "id": 1, "name": "Uma tentativa de descobrir uma chave criptográfica testando todas as combinações possíveis", "alias": "a" },
        { "id": 2, "name": "Um método para acelerar a criptografia de dados", "alias": "b" },
        { "id": 3, "name": "Uma técnica para compactar arquivos criptografados", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },
    {
      "id": 155,
      "question": "O que é um ataque de replay na criptografia?",
      "options": [
        { "id": 1, "name": "Uma técnica onde um invasor intercepta e retransmite dados para enganar o sistema", "alias": "a" },
        { "id": 2, "name": "Um método para acelerar a criptografia de dados", "alias": "b" },
        { "id": 3, "name": "Uma técnica para compactar arquivos criptografados", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },
    {
      "id": 156,
      "question": "O que é um hash criptográfico?",
      "options": [
        { "id": 1, "name": "Uma função que transforma dados em um valor fixo e irreversível", "alias": "a" },
        { "id": 2, "name": "Um método para compactar arquivos", "alias": "b" },
        { "id": 3, "name": "Uma técnica de armazenamento de dados", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },
    {
      "id": 157,
      "question": "Qual é a função da criptografia em blockchain?",
      "options": [
        { "id": 1, "name": "Garantir a segurança e integridade das transações registradas", "alias": "a" },
        { "id": 2, "name": "Compactar os blocos de dados", "alias": "b" },
        { "id": 3, "name": "Acelerar a transmissão de informações", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },
    {
      "id": 158,
      "question": "O que é um certificado digital?",
      "options": [
        { "id": 1, "name": "Um documento eletrônico que autentica a identidade de um usuário ou site", "alias": "a" },
        { "id": 2, "name": "Um código usado para compactar arquivos", "alias": "b" },
        { "id": 3, "name": "Uma técnica de armazenamento de dados", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },
    {
      "id": 159,
      "question": "O que é criptografia de curva elíptica (ECC)?",
      "options": [
        { "id": 1, "name": "Método criptográfico baseado em matemática de curvas elípticas", "alias": "a" },
        { "id": 2, "name": "Protocolo para redes em formato de elipse", "alias": "b" },
        { "id": 3, "name": "Algoritmo para compressão de dados", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "ECC oferece segurança equivalente ao RSA com chaves menores, sendo mais eficiente.",
      "category": "criptografia"
    },
    {
      "id": 160,
      "question": "O que é um hash criptográfico?",
      "options": [
        { "id": 1, "name": "Uma função que transforma dados em um valor fixo e irreversível", "alias": "a" },
        { "id": 2, "name": "Um método para compactar arquivos", "alias": "b" },
        { "id": 3, "name": "Uma técnica de armazenamento de dados", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },
    {
      "id": 161,
      "question": "Qual é a função da criptografia em blockchain?",
      "options": [
        { "id": 1, "name": "Garantir a segurança e integridade das transações registradas", "alias": "a" },
        { "id": 2, "name": "Compactar os blocos de dados", "alias": "b" },
        { "id": 3, "name": "Acelerar a transmissão de informações", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },
    {
      "id": 162,
      "question": "O que é um ataque de força bruta?",
      "options": [
        { "id": 1, "name": "Uma tentativa de descobrir uma chave criptográfica testando todas as combinações possíveis", "alias": "a" },
        { "id": 2, "name": "Um método para acelerar a criptografia de dados", "alias": "b" },
        { "id": 3, "name": "Uma técnica para compactar arquivos criptografados", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },
    {
      "id": 163,
      "question": "O que é um ataque de man-in-the-middle?",
      "options": [
        { "id": 1, "name": "Uma técnica onde um invasor intercepta e altera a comunicação entre duas partes", "alias": "a" },
        { "id": 2, "name": "Um método para acelerar a criptografia de dados", "alias": "b" },
        { "id": 3, "name": "Uma técnica para compactar arquivos criptografados", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },
    {
      "id": 164,
      "question": "Qual é a importância da criptografia em comunicações seguras?",
      "options": [
        { "id": 1, "name": "Protege dados contra acessos não autorizados e garante a privacidade", "alias": "a" },
        { "id": 2, "name": "Acelera a transmissão de informações", "alias": "b" },
        { "id": 3, "name": "Reduz o tamanho dos arquivos", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },
    {
      "id": 165,
      "question": "O que é criptografia homomórfica?",
      "options": [
        { "id": 1, "name": "Uma técnica que permite realizar operações sobre dados criptografados sem precisar descriptografá-los", "alias": "a" },
        { "id": 2, "name": "Um método para compactar arquivos criptografados", "alias": "b" },
        { "id": 3, "name": "Uma técnica de armazenamento de dados", "alias": "c" }
      ],
      "correct": "a",
      "category": "criptografia"
    },      
    {
      "id": 166,
      "question": "O que é Micro Front-End?",
      "options": [
        { "id": 1, "name": "Uma abordagem para dividir aplicações front-end em módulos independentes", "alias": "a" },
        { "id": 2, "name": "Um framework para desenvolvimento de aplicações web", "alias": "b" },
        { "id": 3, "name": "Uma técnica para otimizar imagens em páginas web", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },
    {
      "id": 167,
      "question": "Qual é o principal objetivo do Micro Front-End?",
      "options": [
        { "id": 1, "name": "Permitir que diferentes equipes desenvolvam partes do front-end de forma independente", "alias": "a" },
        { "id": 2, "name": "Reduzir o tamanho dos arquivos CSS", "alias": "b" },
        { "id": 3, "name": "Melhorar a performance de bancos de dados", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },
    {
      "id": 168,
      "question": "Quais são as vantagens do Micro Front-End?",
      "options": [
        { "id": 1, "name": "Escalabilidade, independência de equipes e facilidade de manutenção", "alias": "a" },
        { "id": 2, "name": "Redução da necessidade de testes automatizados", "alias": "b" },
        { "id": 3, "name": "Eliminação da necessidade de versionamento de código", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },
    {
      "id": 169,
      "question": "Qual tecnologia pode ser usada para implementar Micro Front-End?",
      "options": [
        { "id": 1, "name": "Web Components", "alias": "a" },
        { "id": 2, "name": "SQL", "alias": "b" },
        { "id": 3, "name": "Bootstrap", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },
    {
      "id": 170,
      "question": "Como os Micro Front-Ends se comunicam entre si?",
      "options": [
        { "id": 1, "name": "Por meio de eventos e mensagens entre módulos", "alias": "a" },
        { "id": 2, "name": "Apenas por meio de bancos de dados", "alias": "b" },
        { "id": 3, "name": "Usando arquivos estáticos", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },
    {
      "id": 171,
      "question": "Quais são os desafios ao implementar Micro Front-End?",
      "options": [
        { "id": 1, "name": "Gerenciamento de estado, comunicação entre módulos e padronização de estilos", "alias": "a" },
        { "id": 2, "name": "Redução da necessidade de testes automatizados", "alias": "b" },
        { "id": 3, "name": "Eliminação da necessidade de versionamento de código", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },
    {
      "id": 172,
      "question": "Qual é a relação entre Micro Front-End e Microservices?",
      "options": [
        { "id": 1, "name": "Micro Front-End aplica os princípios de Microservices ao desenvolvimento front-end", "alias": "a" },
        { "id": 2, "name": "Microservices são usados apenas para back-end", "alias": "b" },
        { "id": 3, "name": "Micro Front-End substitui completamente os Microservices", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },
    {
      "id": 173,
      "question": "Como o Micro Front-End pode impactar a experiência do usuário?",
      "options": [
        { "id": 1, "name": "Pode melhorar a performance e permitir atualizações mais rápidas", "alias": "a" },
        { "id": 2, "name": "Reduz a necessidade de testes automatizados", "alias": "b" },
        { "id": 3, "name": "Elimina a necessidade de versionamento de código", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },
    {
      "id": 174,
      "question": "Quais são as abordagens para integrar Micro Front-Ends?",
      "options": [
        { "id": 1, "name": "Iframe, Web Components e Single SPA", "alias": "a" },
        { "id": 2, "name": "Apenas usando bancos de dados", "alias": "b" },
        { "id": 3, "name": "Usando arquivos estáticos", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },
    {
      "id": 175,
      "question": "Quando é recomendado usar Micro Front-End?",
      "options": [
        { "id": 1, "name": "Quando há múltiplas equipes trabalhando em um mesmo projeto de forma independente", "alias": "a" },
        { "id": 2, "name": "Quando o projeto não precisa de modularização", "alias": "b" },
        { "id": 3, "name": "Quando o front-end é pequeno e simples", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },      
    {
      "id": 176,
      "question": "O que diferencia Micro Front-End de uma arquitetura monolítica?",
      "options": [
        { "id": 1, "name": "Micro Front-End divide a aplicação em módulos independentes, enquanto a arquitetura monolítica centraliza tudo em um único código", "alias": "a" },
        { "id": 2, "name": "Microservices são usados apenas para back-end", "alias": "b" },
        { "id": 3, "name": "Micro Front-End elimina completamente a necessidade de um back-end", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },
    {
      "id": 177,
      "question": "Como os Micro Front-Ends podem ser carregados em uma aplicação?",
      "options": [
        { "id": 1, "name": "Por meio de módulos independentes carregados dinamicamente", "alias": "a" },
        { "id": 2, "name": "Apenas por meio de bancos de dados", "alias": "b" },
        { "id": 3, "name": "Usando arquivos estáticos", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },
    {
      "id": 178,
      "question": "Quais são os principais desafios ao adotar Micro Front-End?",
      "options": [
        { "id": 1, "name": "Gerenciamento de estado, comunicação entre módulos e padronização de estilos", "alias": "a" },
        { "id": 2, "name": "Redução da necessidade de testes automatizados", "alias": "b" },
        { "id": 3, "name": "Eliminação da necessidade de versionamento de código", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },
    {
      "id": 179,
      "question": "Qual abordagem pode ser usada para compartilhar estado entre Micro Front-Ends?",
      "options": [
        { "id": 1, "name": "Usando um gerenciador de estado global como Redux ou eventos customizados", "alias": "a" },
        { "id": 2, "name": "Apenas por meio de bancos de dados", "alias": "b" },
        { "id": 3, "name": "Usando arquivos estáticos", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },
    {
      "id": 180,
      "question": "Como garantir a consistência visual entre diferentes Micro Front-Ends?",
      "options": [
        { "id": 1, "name": "Utilizando uma biblioteca de componentes compartilhada e padronização de estilos", "alias": "a" },
        { "id": 2, "name": "Criando estilos independentes para cada módulo", "alias": "b" },
        { "id": 3, "name": "Evitando o uso de CSS", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },
    {
      "id": 181,
      "question": "Quais são as formas de integrar Micro Front-Ends em uma aplicação?",
      "options": [
        { "id": 1, "name": "Iframe, Web Components e Single SPA", "alias": "a" },
        { "id": 2, "name": "Apenas usando bancos de dados", "alias": "b" },
        { "id": 3, "name": "Usando arquivos estáticos", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },
    {
      "id": 182,
      "question": "Como o Micro Front-End pode impactar a performance da aplicação?",
      "options": [
        { "id": 1, "name": "Pode aumentar o tempo de carregamento devido à necessidade de carregar múltiplos módulos", "alias": "a" },
        { "id": 2, "name": "Reduz a necessidade de testes automatizados", "alias": "b" },
        { "id": 3, "name": "Elimina a necessidade de versionamento de código", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },
    {
      "id": 183,
      "question": "Qual é a importância da comunicação entre Micro Front-Ends?",
      "options": [
        { "id": 1, "name": "Permite que diferentes módulos troquem informações e mantenham a aplicação sincronizada", "alias": "a" },
        { "id": 2, "name": "Evita que os módulos sejam carregados corretamente", "alias": "b" },
        { "id": 3, "name": "Elimina a necessidade de um back-end", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },
    {
      "id": 184,
      "question": "Quais são os benefícios de usar Web Components em Micro Front-End?",
      "options": [
        { "id": 1, "name": "Permite criar componentes reutilizáveis e independentes de framework", "alias": "a" },
        { "id": 2, "name": "Reduz a necessidade de testes automatizados", "alias": "b" },
        { "id": 3, "name": "Elimina a necessidade de versionamento de código", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },
    {
      "id": 185,
      "question": "Quando **não** é recomendado usar Micro Front-End?",
      "options": [
        { "id": 1, "name": "Quando a aplicação é pequena e não há necessidade de modularização", "alias": "a" },
        { "id": 2, "name": "Quando há múltiplas equipes trabalhando em um mesmo projeto de forma independente", "alias": "b" },
        { "id": 3, "name": "Quando o front-end precisa ser altamente escalável", "alias": "c" }
      ],
      "correct": "a",
      "category": "micro-front-end"
    },      
    {
      "id": 186,
      "question": "O que são testes unitários?",
      "options": [
        { "id": 1, "name": "Uma técnica de teste que verifica o funcionamento de pequenas partes do código isoladamente", "alias": "a" },
        { "id": 2, "name": "Um método para testar a aplicação completa", "alias": "b" },
        { "id": 3, "name": "Uma abordagem para testar apenas a interface gráfica", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },
    {
      "id": 187,
      "question": "Qual é o principal objetivo dos testes unitários?",
      "options": [
        { "id": 1, "name": "Garantir que cada unidade de código funcione corretamente de forma isolada", "alias": "a" },
        { "id": 2, "name": "Testar a integração entre diferentes módulos", "alias": "b" },
        { "id": 3, "name": "Validar a experiência do usuário", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },
    {
      "id": 188,
      "question": "Quais são as vantagens de usar testes unitários?",
      "options": [
        { "id": 1, "name": "Facilitam a manutenção do código e reduzem erros em produção", "alias": "a" },
        { "id": 2, "name": "Aumentam o tempo de desenvolvimento", "alias": "b" },
        { "id": 3, "name": "Eliminam a necessidade de testes automatizados", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },
    {
      "id": 189,
      "question": "O que é um mock em testes unitários?",
      "options": [
        { "id": 1, "name": "Um objeto simulado que imita o comportamento de dependências externas", "alias": "a" },
        { "id": 2, "name": "Um erro encontrado durante a execução dos testes", "alias": "b" },
        { "id": 3, "name": "Uma técnica para testar interfaces gráficas", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },
    {
      "id": 190,
      "question": "Qual ferramenta é amplamente utilizada para testes unitários em Java?",
      "options": [
        { "id": 1, "name": "JUnit", "alias": "a" },
        { "id": 2, "name": "Selenium", "alias": "b" },
        { "id": 3, "name": "Postman", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },
    {
      "id": 191,
      "question": "O que significa TDD (Test-Driven Development)?",
      "options": [
        { "id": 1, "name": "Uma abordagem de desenvolvimento onde os testes são escritos antes do código", "alias": "a" },
        { "id": 2, "name": "Uma técnica para testar interfaces gráficas", "alias": "b" },
        { "id": 3, "name": "Um método para testar apenas a experiência do usuário", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },
    {
      "id": 192,
      "question": "Qual é a diferença entre testes unitários e testes de integração?",
      "options": [
        { "id": 1, "name": "Testes unitários verificam partes isoladas do código, enquanto testes de integração validam a comunicação entre módulos", "alias": "a" },
        { "id": 2, "name": "Testes unitários são aplicados apenas em interfaces gráficas", "alias": "b" },
        { "id": 3, "name": "Testes de integração são usados apenas para bancos de dados", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },
    {
      "id": 193,
      "question": "Por que é importante automatizar testes unitários?",
      "options": [
        { "id": 1, "name": "Para garantir que os testes sejam executados de forma consistente e rápida", "alias": "a" },
        { "id": 2, "name": "Para eliminar a necessidade de revisão de código", "alias": "b" },
        { "id": 3, "name": "Para reduzir a necessidade de versionamento de código", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },
    {
      "id": 194,
      "question": "O que é cobertura de testes?",
      "options": [
        { "id": 1, "name": "A porcentagem do código que é testada por testes unitários", "alias": "a" },
        { "id": 2, "name": "Um relatório de erros encontrados durante os testes", "alias": "b" },
        { "id": 3, "name": "Uma técnica para testar interfaces gráficas", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },
    {
      "id": 195,
      "question": "Qual é a melhor prática ao escrever testes unitários?",
      "options": [
        { "id": 1, "name": "Criar testes pequenos e independentes que validem apenas uma funcionalidade por vez", "alias": "a" },
        { "id": 2, "name": "Testar todas as funcionalidades em um único teste", "alias": "b" },
        { "id": 3, "name": "Evitar o uso de testes automatizados", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },      
    {
      "id": 196,
      "question": "O que é um stub em testes unitários?",
      "options": [
        { "id": 1, "name": "Um objeto substituto que retorna respostas pré-definidas para chamadas de métodos", "alias": "a" },
        { "id": 2, "name": "Um erro encontrado durante a execução dos testes", "alias": "b" },
        { "id": 3, "name": "Uma técnica para testar interfaces gráficas", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },
    {
      "id": 197,
      "question": "Qual é a diferença entre mocks e stubs?",
      "options": [
        { "id": 1, "name": "Mocks verificam interações entre objetos, enquanto stubs retornam valores pré-definidos", "alias": "a" },
        { "id": 2, "name": "Mocks são usados apenas para testes de integração", "alias": "b" },
        { "id": 3, "name": "Stubs são usados apenas para testes de interface", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },
    {
      "id": 198,
      "question": "O que é um teste de regressão?",
      "options": [
        { "id": 1, "name": "Um teste que verifica se alterações no código não introduziram novos erros", "alias": "a" },
        { "id": 2, "name": "Um teste que mede a performance do sistema", "alias": "b" },
        { "id": 3, "name": "Um teste que verifica apenas a interface gráfica", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },
    {
      "id": 199,
      "question": "Qual é a importância da independência dos testes unitários?",
      "options": [
        { "id": 1, "name": "Permite que cada teste seja executado isoladamente sem depender de outros testes", "alias": "a" },
        { "id": 2, "name": "Reduz a necessidade de testes automatizados", "alias": "b" },
        { "id": 3, "name": "Elimina a necessidade de versionamento de código", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },
    {
      "id": 200,
      "question": "O que é um falso positivo em testes unitários?",
      "options": [
        { "id": 1, "name": "Um teste que passa mesmo quando há um erro no código", "alias": "a" },
        { "id": 2, "name": "Um teste que falha devido a um erro externo", "alias": "b" },
        { "id": 3, "name": "Um teste que verifica apenas a interface gráfica", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },
    {
      "id": 201,
      "question": "O que é um falso negativo em testes unitários?",
      "options": [
        { "id": 1, "name": "Um teste que falha mesmo quando o código está correto", "alias": "a" },
        { "id": 2, "name": "Um teste que mede a performance do sistema", "alias": "b" },
        { "id": 3, "name": "Um teste que verifica apenas a interface gráfica", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },
    {
      "id": 202,
      "question": "Qual é a relação entre testes unitários e refatoração de código?",
      "options": [
        { "id": 1, "name": "Testes unitários ajudam a garantir que a refatoração não introduza novos erros", "alias": "a" },
        { "id": 2, "name": "Refatoração elimina a necessidade de testes unitários", "alias": "b" },
        { "id": 3, "name": "Testes unitários são usados apenas para validar interfaces gráficas", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },
    {
      "id": 203,
      "question": "O que é um framework de testes unitários?",
      "options": [
        { "id": 1, "name": "Uma biblioteca que facilita a criação e execução de testes unitários", "alias": "a" },
        { "id": 2, "name": "Um método para testar apenas a experiência do usuário", "alias": "b" },
        { "id": 3, "name": "Uma técnica para testar interfaces gráficas", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },
    {
      "id": 204,
      "question": "Qual é a importância da cobertura de testes?",
      "options": [
        { "id": 1, "name": "Ajuda a identificar partes do código que não estão sendo testadas", "alias": "a" },
        { "id": 2, "name": "Reduz a necessidade de testes automatizados", "alias": "b" },
        { "id": 3, "name": "Elimina a necessidade de versionamento de código", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },
    {
      "id": 205,
      "question": "O que é um teste parametrizado?",
      "options": [
        { "id": 1, "name": "Um teste que executa o mesmo código com diferentes conjuntos de dados", "alias": "a" },
        { "id": 2, "name": "Um teste que mede a performance do sistema", "alias": "b" },
        { "id": 3, "name": "Um teste que verifica apenas a interface gráfica", "alias": "c" }
      ],
      "correct": "a",
      "category": "testes-unitarios"
    },
    {
      "id": 206,
      "question": "O que geralmente causa o erro 'Uncaught TypeError: Cannot read property' em JavaScript?",
      "options": [
        { "id": 1, "name": "Tentar acessar uma propriedade de um valor undefined ou null", "alias": "a" },
        { "id": 2, "name": "Erro de sintaxe no HTML", "alias": "b" },
        { "id": 3, "name": "Falta de ponto e vírgula", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 207,
      "question": "O que significa o erro '404 Not Found' ao acessar uma página web?",
      "options": [
        { "id": 1, "name": "A página requisitada não foi encontrada no servidor", "alias": "a" },
        { "id": 2, "name": "O servidor está fora do ar", "alias": "b" },
        { "id": 3, "name": "O site está sem conexão com a internet", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 208,
      "question": "O que pode causar o erro 'CORS policy: No 'Access-Control-Allow-Origin''?",
      "options": [
        { "id": 1, "name": "Fazer requisição para um domínio diferente sem permissões adequadas", "alias": "a" },
        { "id": 2, "name": "Erro de sintaxe no CSS", "alias": "b" },
        { "id": 3, "name": "Falta de ponto e vírgula no JavaScript", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 209,
      "question": "O que significa o erro 'ReferenceError: x is not defined'?",
      "options": [
        { "id": 1, "name": "A variável x foi usada antes de ser declarada", "alias": "a" },
        { "id": 2, "name": "A variável x foi declarada duas vezes", "alias": "b" },
        { "id": 3, "name": "A variável x é uma palavra reservada", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 210,
      "question": "O que pode causar o erro 'Unexpected token' em JavaScript?",
      "options": [
        { "id": 1, "name": "Erro de sintaxe, como falta de parênteses ou chaves", "alias": "a" },
        { "id": 2, "name": "Falta de conexão com o banco de dados", "alias": "b" },
        { "id": 3, "name": "Erro de permissão no servidor", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 211,
      "question": "O que pode causar o erro 'Maximum call stack size exceeded'?",
      "options": [
        { "id": 1, "name": "Recursão infinita em uma função", "alias": "a" },
        { "id": 2, "name": "Falta de ponto e vírgula", "alias": "b" },
        { "id": 3, "name": "Erro de sintaxe no HTML", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 212,
      "question": "O que significa o erro 'SyntaxError: Unexpected end of input'?",
      "options": [
        { "id": 1, "name": "O código terminou antes de fechar todos os blocos ou parênteses", "alias": "a" },
        { "id": 2, "name": "Falta de ponto e vírgula", "alias": "b" },
        { "id": 3, "name": "Erro de permissão no servidor", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 213,
      "question": "O que pode causar o erro 'Failed to fetch' ao fazer uma requisição fetch?",
      "options": [
        { "id": 1, "name": "Problemas de rede ou URL incorreta", "alias": "a" },
        { "id": 2, "name": "Erro de sintaxe no CSS", "alias": "b" },
        { "id": 3, "name": "Falta de ponto e vírgula no JavaScript", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 214,
      "question": "O que significa o erro 'TypeError: x is not a function'?",
      "options": [
        { "id": 1, "name": "Tentar chamar uma variável que não é uma função", "alias": "a" },
        { "id": 2, "name": "A função x não foi importada", "alias": "b" },
        { "id": 3, "name": "A função x foi declarada duas vezes", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 215,
      "question": "O que pode causar o erro 'Cannot set property of undefined'?",
      "options": [
        { "id": 1, "name": "Tentar atribuir um valor a uma propriedade de um objeto que não existe", "alias": "a" },
        { "id": 2, "name": "Erro de sintaxe no CSS", "alias": "b" },
        { "id": 3, "name": "Falta de ponto e vírgula no JavaScript", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 216,
      "question": "O que é o Virtual DOM em frameworks como React?",
      "options": [
        { "id": 1, "name": "Uma representação leve do DOM real usada para otimizar atualizações", "alias": "a" },
        { "id": 2, "name": "Um novo tipo de navegador", "alias": "b" },
        { "id": 3, "name": "Uma biblioteca para manipular CSS", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 217,
      "question": "Qual propriedade CSS é usada para criar sombras em elementos?",
      "options": [
        { "id": 1, "name": "box-shadow", "alias": "a" },
        { "id": 2, "name": "shadow", "alias": "b" },
        { "id": 3, "name": "element-shadow", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 218,
      "question": "O que faz a propriedade CSS 'position: sticky'?",
      "options": [
        { "id": 1, "name": "Mantém o elemento fixo até atingir um determinado ponto de rolagem", "alias": "a" },
        { "id": 2, "name": "Deixa o elemento sempre fixo na tela", "alias": "b" },
        { "id": 3, "name": "Centraliza o elemento na tela", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 219,
      "question": "O que é o conceito de 'componentização' em frameworks modernos?",
      "options": [
        { "id": 1, "name": "Dividir a interface em partes reutilizáveis chamadas componentes", "alias": "a" },
        { "id": 2, "name": "Criar apenas uma página para toda a aplicação", "alias": "b" },
        { "id": 3, "name": "Usar apenas funções globais", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 220,
      "question": "Qual evento JavaScript é disparado quando um formulário é enviado?",
      "options": [
        { "id": 1, "name": "submit", "alias": "a" },
        { "id": 2, "name": "send", "alias": "b" },
        { "id": 3, "name": "post", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 221,
      "question": "O que é o conceito de 'mobile first' no desenvolvimento front-end?",
      "options": [
        { "id": 1, "name": "Desenvolver primeiro para dispositivos móveis e depois adaptar para telas maiores", "alias": "a" },
        { "id": 2, "name": "Desenvolver apenas para desktop", "alias": "b" },
        { "id": 3, "name": "Priorizar animações em dispositivos móveis", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 222,
      "question": "Qual propriedade CSS é usada para arredondar os cantos de um elemento?",
      "options": [
        { "id": 1, "name": "border-radius", "alias": "a" },
        { "id": 2, "name": "corner-radius", "alias": "b" },
        { "id": 3, "name": "round-corner", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 223,
      "question": "O que é o atributo 'tabindex' em HTML?",
      "options": [
        { "id": 1, "name": "Define a ordem de navegação por tabulação entre elementos", "alias": "a" },
        { "id": 2, "name": "Define o tamanho da aba do navegador", "alias": "b" },
        { "id": 3, "name": "Define o título da aba", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 224,
      "question": "Qual é a função do atributo 'autofocus' em um input HTML?",
      "options": [
        { "id": 1, "name": "Faz o campo receber foco automaticamente ao carregar a página", "alias": "a" },
        { "id": 2, "name": "Deixa o campo em negrito", "alias": "b" },
        { "id": 3, "name": "Desabilita o campo", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 225,
      "question": "O que é o atributo 'placeholder' em um input HTML?",
      "options": [
        { "id": 1, "name": "Exibe um texto de dica dentro do campo até que o usuário digite algo", "alias": "a" },
        { "id": 2, "name": "Define o valor inicial do campo", "alias": "b" },
        { "id": 3, "name": "Define o tipo do campo", "alias": "c" }
      ],
      "correct": "a",
      "category": "front-end"
    },
    {
      "id": 226,
      "question": "Qual é a diferença entre 'interface' e 'type' em TypeScript?",
      "options": [
        { "id": 1, "name": "Interfaces são usadas apenas para classes, enquanto types são usados para funções", "alias": "a" },
        { "id": 2, "name": "Interfaces podem ser estendidas múltiplas vezes, enquanto types não", "alias": "b" },
        { "id": 3, "name": "Types são exclusivos para definir tipos primitivos", "alias": "c" }
      ],
    "correct": "b",
    "category": "typescript"
  },    {
      "id": 227,
      "question": "O que é um 'union type' em TypeScript?",
      "options": [
        { "id": 1, "name": "Um tipo que pode ser um de vários tipos especificados", "alias": "a" },
        { "id": 2, "name": "Um tipo que combina dois tipos em um só", "alias": "b" },
        { "id": 3, "name": "Um tipo exclusivo para arrays", "alias": "c" }
      ],
      "correct": "a",
      "category": "typescript"
    },
    {
      "id": 228,
      "question": "O que é um 'intersection type' em TypeScript?",
      "options": [
        { "id": 1, "name": "Um tipo que combina múltiplos tipos em um só", "alias": "a" },
        { "id": 2, "name": "Um tipo que pode ser um de vários tipos especificados", "alias": "b" },
        { "id": 3, "name": "Um tipo exclusivo para funções", "alias": "c" }
      ],
      "correct": "a",
      "category": "typescript"
    },
    {
      "id": 229,
      "question": "O que é o operador 'as' em TypeScript?",
      "options": [
        { "id": 1, "name": "Um operador de asserção de tipo que informa ao compilador para tratar uma variável como um tipo específico", "alias": "a" },
        { "id": 2, "name": "Um operador para definir variáveis constantes", "alias": "b" },
        { "id": 3, "name": "Um operador para criar arrays", "alias": "c" }
      ],
      "correct": "a",
      "category": "typescript"
    },
    {
      "id": 230,
      "question": "O que é o 'type assertion' em TypeScript?",
      "options": [
        { "id": 1, "name": "Uma forma de informar ao compilador sobre o tipo de uma variável quando ele não consegue inferir automaticamente", "alias": "a" },
        { "id": 2, "name": "Uma técnica para criar tipos genéricos", "alias": "b" },
        { "id": 3, "name": "Uma maneira de definir interfaces", "alias": "c" }
      ],
      "correct": "a",
      "category": "typescript"
    },
    {
      "id": 231,
      "question": "Qual é o principal benefício de aplicar o princípio DRY (Don't Repeat Yourself)?",
      "options": [
        { "id": 1, "name": "Melhorar a performance do código", "alias": "a" },
        { "id": 2, "name": "Evitar duplicação e facilitar manutenção", "alias": "b" },
        { "id": 3, "name": "Aumentar a complexidade do sistema", "alias": "c" }
      ],
      "correct": "b",
      "category": "boas-praticas"
    },
    {
      "id": 252,
      "question": "Por que é importante nomear variáveis de forma clara e descritiva?",
      "options": [
        { "id": 1, "name": "Para que o código fique mais difícil de entender", "alias": "a" },
        { "id": 2, "name": "Para facilitar a leitura e manutenção do código", "alias": "b" },
        { "id": 3, "name": "Para reduzir o tempo de compilação", "alias": "c" }
      ],
      "correct": "b",
      "category": "boas-praticas"
    },
    {
      "id": 253,
      "question": "O que significa o princípio KISS (Keep It Simple, Stupid)?",
      "options": [
        { "id": 1, "name": "Evitar comentários no código", "alias": "a" },
        { "id": 2, "name": "Manter o código o mais simples e direto possível", "alias": "b" },
        { "id": 3, "name": "Utilizar apenas variáveis globais", "alias": "c" }
      ],
      "correct": "b",
      "category": "boas-praticas"
    },
    {
      "id": 254,
      "question": "Qual é a vantagem de dividir o código em módulos ou componentes?",
      "options": [
        { "id": 1, "name": "Facilita a reutilização e a manutenção", "alias": "a" },
        { "id": 2, "name": "Dificulta a leitura do código", "alias": "b" },
        { "id": 3, "name": "Aumenta o tempo de execução", "alias": "c" }
      ],
      "correct": "a",
      "category": "boas-praticas"
    },
    {
      "id": 255,
      "question": "Por que é importante escrever testes automatizados?",
      "options": [
        { "id": 1, "name": "Para aumentar a complexidade do projeto", "alias": "a" },
        { "id": 2, "name": "Para garantir que o código funcione como esperado e facilitar refatorações", "alias": "b" },
        { "id": 3, "name": "Para evitar o uso de comentários", "alias": "c" }
      ],
      "correct": "b",
      "category": "boas-praticas"
    },
    {
      "id": 256,
      "question": "O que é um 'code smell'?",
      "options": [
        { "id": 1, "name": "Um erro de sintaxe no código", "alias": "a" },
        { "id": 2, "name": "Um indicativo de que o código pode ser melhorado", "alias": "b" },
        { "id": 3, "name": "Um tipo de variável", "alias": "c" }
      ],
      "correct": "b",
      "category": "boas-praticas"
    },
    {
      "id": 257,
      "question": "Qual é a importância de seguir um padrão de codificação (coding style)?",
      "options": [
        { "id": 1, "name": "Para tornar o código mais difícil de entender", "alias": "a" },
        { "id": 2, "name": "Para garantir consistência e facilitar a colaboração entre desenvolvedores", "alias": "b" },
        { "id": 3, "name": "Para aumentar o tamanho do arquivo", "alias": "c" }
      ],
      "correct": "b",
      "category": "boas-praticas"
    },
    {
      "id": 258,
      "question": "O que é refatoração de código?",
      "options": [
        { "id": 1, "name": "Adicionar novas funcionalidades ao código", "alias": "a" },
        { "id": 2, "name": "Modificar o código para melhorar sua estrutura sem alterar seu comportamento", "alias": "b" },
        { "id": 3, "name": "Remover comentários do código", "alias": "c" }
      ],
      "correct": "b",
      "category": "boas-praticas"
    },
    {
      "id": 259,
      "question": "Por que é importante documentar o código?",
      "options": [
        { "id": 1, "name": "Para dificultar a leitura do código", "alias": "a" },
        { "id": 2, "name": "Para ajudar outros desenvolvedores (e você mesmo) a entenderem o propósito e funcionamento do código", "alias": "b"},
        { "id": 3, "name": "Para aumentar o tamanho do arquivo", "alias": "c" }
      ],
      "correct": "b",
      "category": "boas-praticas"
    },
    {
      "id": 256,
      "question": "O que significa CI no contexto de desenvolvimento de software?",
      "options": [
        { "id": 1, "name": "Continuous Integration", "alias": "a" },
        { "id": 2, "name": "Code Injection", "alias": "b" },
        { "id": 3, "name": "Centralized Infrastructure", "alias": "c" }
      ],
      "correct": "a",
      "category": "ci-cd"
    },
    {
      "id": 257,
      "question": "Qual é o objetivo principal da entrega contínua (CD)?",
      "options": [
        { "id": 1, "name": "Executar testes manuais", "alias": "a" },
        { "id": 2, "name": "Automatizar o processo de deploy com segurança e frequência", "alias": "b" },
        { "id": 3, "name": "Evitar atualizações no sistema", "alias": "c" }
      ],
      "correct": "b",
      "category": "ci-cd"
    },
    {
      "id": 258,
      "question": "Qual ferramenta é comumente usada para pipelines de CI/CD?",
      "options": [
        { "id": 1, "name": "Jenkins", "alias": "a" },
        { "id": 2, "name": "Photoshop", "alias": "b" },
        { "id": 3, "name": "Excel", "alias": "c" }
      ],
      "correct": "a",
      "category": "ci-cd"
    },
    {
      "id": 259,
      "question": "Em um pipeline CI/CD, o que geralmente acontece após o commit de código?",
      "options": [
        { "id": 1, "name": "O código é ignorado até o próximo deploy manual", "alias": "a" },
        { "id": 2, "name": "O pipeline é disparado para compilar, testar e preparar o deploy", "alias": "b" },
        { "id": 3, "name": "O código é enviado diretamente para produção", "alias": "c" }
      ],
      "correct": "b",
      "category": "ci-cd"
    },
    {
      "id": 260,
      "question": "Qual é uma vantagem do uso de CI/CD em projetos de software?",
      "options": [
        { "id": 1, "name": "Redução da frequência de deploys", "alias": "a" },
        { "id": 2, "name": "Maior agilidade e confiabilidade nas entregas", "alias": "b" },
        { "id": 3, "name": "Eliminação completa de bugs", "alias": "c" }
      ],
      "correct": "b",
      "category": "ci-cd"
    },
    {
      "id": 261,
      "question": "O que é um pipeline de CI/CD?",
      "options": [
        { "id": 1, "name": "Um conjunto de comandos para estilizar o código", "alias": "a" },
        { "id": 2, "name": "Uma sequência automatizada de etapas para compilar, testar e implantar software", "alias": "b" },
        { "id": 3, "name": "Um script para limpar o cache do servidor", "alias": "c" }
      ],
      "correct": "b",
      "category": "ci-cd"
    },
    {
      "id": 262,
      "question": "Qual prática ajuda a evitar conflitos durante a integração contínua?",
      "options": [
        { "id": 1, "name": "Commits frequentes e pequenos", "alias": "a" },
        { "id": 2, "name": "Deploy manual em produção", "alias": "b" },
        { "id": 3, "name": "Uso exclusivo de branches longos", "alias": "c" }
      ],
      "correct": "a",
      "category": "ci-cd"
    },
    {
      "id": 263,
      "question": "O que é um artefato em um processo de CI/CD?",
      "options": [
        { "id": 1, "name": "Um arquivo gerado durante o build que pode ser implantado", "alias": "a" },
        { "id": 2, "name": "Um erro de compilação", "alias": "b" },
        { "id": 3, "name": "Um script de teste automatizado", "alias": "c" }
      ],
      "correct": "a",
      "category": "ci-cd"
    },
    {
      "id": 264,
      "question": "Qual é o papel dos testes automatizados em CI/CD?",
      "options": [
        { "id": 1, "name": "Verificar se o código está formatado corretamente", "alias": "a" },
        { "id": 2, "name": "Garantir que novas alterações não quebrem funcionalidades existentes", "alias": "b" },
        { "id": 3, "name": "Reduzir o tempo de deploy manual", "alias": "c" }
      ],
      "correct": "b",
      "category": "ci-cd"
    },
    {
      "id": 265,
      "question": "O que é um ambiente de staging em CI/CD?",
      "options": [
        { "id": 1, "name": "Um ambiente de produção com dados reais", "alias": "a" },
        { "id": 2, "name": "Um ambiente de testes que simula a produção", "alias": "b" },
        { "id": 3, "name": "Um ambiente usado apenas para desenvolvimento local", "alias": "c" }
      ],
      "correct": "b",
      "category": "ci-cd"
    },
    {
      "id": 266,
      "question": "Qual é o principal objetivo de um code review?",
      "options": [
        { "id": 1, "name": "Criticar o estilo pessoal do desenvolvedor", "alias": "a" },
        { "id": 2, "name": "Garantir qualidade, legibilidade e detectar possíveis erros", "alias": "b" },
        { "id": 3, "name": "Reduzir o número de commits no projeto", "alias": "c" }
      ],
      "correct": "b",
      "category": "code-review"
    },
    {
      "id": 267,
      "question": "O que deve ser evitado durante um code review?",
      "options": [
        { "id": 1, "name": "Comentários construtivos e sugestões", "alias": "a" },
        { "id": 2, "name": "Discussões sobre boas práticas", "alias": "b" },
        { "id": 3, "name": "Críticas pessoais e subjetivas", "alias": "c" }
      ],
      "correct": "c",
      "category": "code-review"
    },
    {
      "id": 268,
      "question": "Qual é uma boa prática ao revisar código de outra pessoa?",
      "options": [
        { "id": 1, "name": "Testar o código antes de aprovar", "alias": "a" },
        { "id": 2, "name": "Ignorar os testes automatizados", "alias": "b" },
        { "id": 3, "name": "Aprovar sem ler se o autor é experiente", "alias": "c" }
      ],
      "correct": "a",
      "category": "code-review"
    },
    {
      "id": 269,
      "question": "Por que é importante manter o escopo pequeno em um pull request?",
      "options": [
        { "id": 1, "name": "Facilita a revisão e reduz chances de erros", "alias": "a" },
        { "id": 2, "name": "Permite adicionar mais funcionalidades de uma vez", "alias": "b" },
        { "id": 3, "name": "Evita que outros desenvolvedores vejam o código", "alias": "c" }
      ],
      "correct": "a",
      "category": "code-review"
    },
    {
      "id": 270,
      "question": "Qual ferramenta é comumente usada para realizar code reviews em projetos Git?",
      "options": [
        { "id": 1, "name": "GitHub", "alias": "a" },
        { "id": 2, "name": "Photoshop", "alias": "b" },
        { "id": 3, "name": "Excel", "alias": "c" }
      ],
      "correct": "a",
      "category": "code-review"
    },
    {
      "id": 271,
      "question": "Por que é importante revisar testes automatizados durante o code review?",
      "options": [
        { "id": 1, "name": "Para garantir que o código esteja bem documentado", "alias": "a" },
        { "id": 2, "name": "Para verificar se os testes cobrem os cenários esperados", "alias": "b" },
        { "id": 3, "name": "Para remover todos os testes do projeto", "alias": "c" }
      ],
      "correct": "b",
      "category": "code-review"
    },
    {
      "id": 272,
      "question": "Qual é uma boa prática ao escrever comentários em um code review?",
      "options": [
        { "id": 1, "name": "Ser claro, objetivo e respeitoso", "alias": "a" },
        { "id": 2, "name": "Usar linguagem agressiva para reforçar pontos", "alias": "b" },
        { "id": 3, "name": "Evitar qualquer tipo de comentário", "alias": "c" }
      ],
      "correct": "a",
      "category": "code-review"
    },
    {
      "id": 273,
      "question": "O que significa aprovar um pull request?",
      "options": [
        { "id": 1, "name": "Que o código foi revisado e está pronto para ser mesclado", "alias": "a" },
        { "id": 2, "name": "Que o código será deletado", "alias": "b" },
        { "id": 3, "name": "Que o autor deve reescrever tudo", "alias": "c" }
      ],
      "correct": "a",
      "category": "code-review"
    },
    {
      "id": 274,
      "question": "Qual é o impacto de um code review bem feito na qualidade do software?",
      "options": [
        { "id": 1, "name": "Reduz bugs e melhora a legibilidade do código", "alias": "a" },
        { "id": 2, "name": "Aumenta o tempo de desenvolvimento sem benefícios", "alias": "b" },
        { "id": 3, "name": "Impede que o código seja executado", "alias": "c" }
      ],
      "correct": "a",
      "category": "code-review"
    },
    {
      "id": 275,
      "question": "Quando é ideal realizar um code review?",
      "options": [
        { "id": 1, "name": "Antes de mesclar o código na branch principal", "alias": "a" },
        { "id": 2, "name": "Após o deploy em produção", "alias": "b" },
        { "id": 3, "name": "Durante a criação do repositório", "alias": "c" }
      ],
      "correct": "a",
      "category": "code-review"
    },
    {
      "id": 276,
      "question": "O que é o Figma?",
      "options": [
        { "id": 1, "name": "Uma ferramenta de edição de vídeo", "alias": "a" },
        { "id": 2, "name": "Uma plataforma de design colaborativo baseada em nuvem", "alias": "b" },
        { "id": 3, "name": "Um sistema de gerenciamento de banco de dados", "alias": "c" }
      ],
      "correct": "b",
      "category": "figma"
    },
    {
      "id": 277,
      "question": "Qual recurso do Figma permite criar componentes reutilizáveis?",
      "options": [
        { "id": 1, "name": "Frames", "alias": "a" },
        { "id": 2, "name": "Prototypes", "alias": "b" },
        { "id": 3, "name": "Components", "alias": "c" }
      ],
      "correct": "c",
      "category": "figma"
    },
    {
      "id": 278,
      "question": "O que é o recurso 'Auto Layout' no Figma?",
      "options": [
        { "id": 1, "name": "Uma forma de aplicar estilos CSS automaticamente", "alias": "a" },
        { "id": 2, "name": "Uma funcionalidade que organiza elementos dinamicamente com base em regras de layout", "alias": "b" },
        { "id": 3, "name": "Um plugin para exportar imagens", "alias": "c" }
      ],
      "correct": "b",
      "category": "figma"
    },
    {
      "id": 279,
      "question": "Qual vantagem do Figma em relação a ferramentas tradicionais de design?",
      "options": [
        { "id": 1, "name": "Funciona apenas offline", "alias": "a" },
        { "id": 2, "name": "Permite colaboração em tempo real entre membros da equipe", "alias": "b" },
        { "id": 3, "name": "Requer instalação local obrigatória", "alias": "c" }
      ],
      "correct": "b",
      "category": "figma"
    },
    {
      "id": 280,
      "question": "O que é o FigJam dentro do ecossistema Figma?",
      "options": [
        { "id": 1, "name": "Uma ferramenta de prototipagem avançada", "alias": "a" },
        { "id": 2, "name": "Uma extensão para exportar código", "alias": "b" },
        { "id": 3, "name": "Uma ferramenta colaborativa para brainstorming e diagramas", "alias": "c" }
      ],
      "correct": "c",
      "category": "figma"
    },
    {
      "id": 281,
      "question": "Qual é a função do recurso 'Prototype' no Figma?",
      "options": [
        { "id": 1, "name": "Criar animações para vídeos", "alias": "a" },
        { "id": 2, "name": "Simular a navegação entre telas e interações", "alias": "b" },
        { "id": 3, "name": "Exportar o projeto para código HTML", "alias": "c" }
      ],
      "correct": "b",
      "category": "figma"
    },
    {
      "id": 282,
      "question": "Como os desenvolvedores geralmente acessam especificações de design no Figma?",
      "options": [
        { "id": 1, "name": "Através do modo 'Inspect'", "alias": "a" },
        { "id": 2, "name": "Exportando o projeto como PDF", "alias": "b" },
        { "id": 3, "name": "Copiando manualmente os estilos", "alias": "c" }
      ],
      "correct": "a",
      "category": "figma"
    },
    {
      "id": 283,
      "question": "O que são 'Variants' em Figma?",
      "options": [
        { "id": 1, "name": "Versões alternativas de arquivos exportados", "alias": "a" },
        { "id": 2, "name": "Componentes com diferentes estados agrupados em um único elemento", "alias": "b" },
        { "id": 3, "name": "Plugins para alterar temas", "alias": "c" }
      ],
      "correct": "b",
      "category": "figma"
    },
    {
      "id": 284,
      "question": "Qual é o benefício de usar estilos compartilhados no Figma?",
      "options": [
        { "id": 1, "name": "Permite alterar o layout automaticamente", "alias": "a" },
        { "id": 2, "name": "Facilita a consistência visual e manutenção do design", "alias": "b" },
        { "id": 3, "name": "Impede que outros editem o projeto", "alias": "c" }
      ],
      "correct": "b",
      "category": "figma"
    },
    {
      "id": 285,
      "question": "Como é possível colaborar em tempo real no Figma?",
      "options": [
        { "id": 1, "name": "Compartilhando o arquivo via e-mail", "alias": "a" },
        { "id": 2, "name": "Convidando membros para editar diretamente no navegador", "alias": "b" },
        { "id": 3, "name": "Exportando o projeto para o Google Drive", "alias": "c" }
      ],
      "correct": "b",
      "category": "figma"
    },
    {
      "id": 286,
      "question": "Qual é a diferença entre '==' e '===' em JavaScript?",
      "options": [
        { "id": 1, "name": "'==' compara apenas valores, enquanto '===' compara valor e tipo", "alias": "a" },
        { "id": 2, "name": "Ambos são iguais e podem ser usados indistintamente", "alias": "b" },
        { "id": 3, "name": "'===' é usado apenas em TypeScript", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "'==' permite coerção de tipos, enquanto '===' é uma comparação estrita.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Sempre uso '===' (strict equality) porque é mais previsível. O '==' faz coerção de tipos que pode causar bugs sutis. Por exemplo, '0' == false retorna true, mas '0' === false retorna false. Em produção, prefiro ser explícito e evitar comportamentos inesperados."
    },
    {
      "id": 287,
      "question": "Explique o ciclo de vida de um componente Angular.",
      "options": [
        { "id": 1, "name": "Inclui fases como ngOnInit, ngOnChanges e ngOnDestroy", "alias": "a" },
        { "id": 2, "name": "É composto apenas por ngCreate e ngDelete", "alias": "b" },
        { "id": 3, "name": "Não possui ciclo de vida definido", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "O ciclo de vida do Angular inclui hooks como ngOnInit, ngOnChanges, ngAfterViewInit e ngOnDestroy.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: O Angular possui hooks de ciclo de vida que permitem executar código em momentos específicos. Uso ngOnInit para inicialização, ngOnChanges para reagir a mudanças de @Input, ngAfterViewInit quando preciso acessar elementos DOM, e ngOnDestroy para cleanup de subscriptions e evitar memory leaks. É fundamental implementar OnDestroy ao trabalhar com Observables."
    },
    {
      "id": 288,
      "question": "Como você garantiria qualidade de código em um projeto colaborativo?",
      "options": [
        { "id": 1, "name": "Utilizando code reviews, testes automatizados e linters", "alias": "a" },
        { "id": 2, "name": "Aprovando todos os pull requests automaticamente", "alias": "b" },
        { "id": 3, "name": "Editando diretamente na branch principal", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "A qualidade é garantida através de múltiplas camadas: revisão de código, testes e ferramentas automatizadas.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Implemento uma estratégia em camadas: 1) Linters (ESLint, Prettier) para padronização automática, 2) Testes unitários com cobertura mínima de 80%, 3) Code reviews obrigatórios com pelo menos 2 aprovações, 4) Pipeline CI/CD que bloqueia merge se testes falharem, 5) SonarQube para análise de qualidade. Também promovo pair programming para compartilhar conhecimento."
    },
    {
      "id": 289,
      "question": "Quais são os principais métodos HTTP usados em APIs REST?",
      "options": [
        { "id": 1, "name": "GET, POST, PUT, PATCH, DELETE", "alias": "a" },
        { "id": 2, "name": "SEND, RECEIVE, UPDATE, REMOVE", "alias": "b" },
        { "id": 3, "name": "CONNECT, TRACE, OPTIONS", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "GET recupera dados, POST cria, PUT substitui completamente, PATCH atualiza parcialmente, DELETE remove recursos.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Uso cada método com seu propósito específico: GET para consultas (idempotente e cacheable), POST para criar recursos únicos, PUT para substituição completa (idempotente), PATCH para atualizações parciais, DELETE para remoção. Sempre implemento status codes adequados: 200 para sucesso, 201 para criação, 404 para não encontrado. Isso garante uma API RESTful bem estruturada."
    },
    {
      "id": 290,
      "question": "Qual é a diferença entre integração contínua (CI) e entrega contínua (CD)?",
      "options": [
        { "id": 1, "name": "CI foca em integrar código frequentemente; CD automatiza o deploy após testes", "alias": "a" },
        { "id": 2, "name": "CI é usado apenas em projetos mobile; CD em projetos web", "alias": "b" },
        { "id": 3, "name": "Ambos significam a mesma coisa", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "CI automatiza integração e testes; CD automatiza o processo de deployment.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: CI é sobre integrar código frequentemente - cada commit dispara build e testes automatizados. CD vai além: automatiza o deployment para diferentes ambientes. Na prática, uso GitHub Actions onde CI roda testes a cada PR, e CD faz deploy automático para staging quando merge na main, mas deploy para produção requer aprovação manual. Isso garante qualidade e agilidade com segurança."
    },
    {
      "id": 291,
      "question": "O que representa o 'S' no acrônimo SOLID?",
      "options": [
        { "id": 1, "name": "Single Responsibility Principle", "alias": "a" },
        { "id": 2, "name": "Simple Routing Protocol", "alias": "b" },
        { "id": 3, "name": "Secure Resource Policy", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "Single Responsibility Principle: cada classe deve ter apenas uma razão para mudar.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: O Single Responsibility Principle determina que cada classe deve ter apenas uma responsabilidade. Por exemplo, divido UserService em UserRepository (acesso a dados), UserValidator (validações) e UserNotifier (notificações). Isso facilita testes, manutenção e reduz acoplamento. Quando preciso modificar a validação, só altero UserValidator sem impactar outras funcionalidades."
    },
    {
      "id": 292,
      "question": "Qual é a ideia central do princípio Open/Closed (O de SOLID)?",
      "options": [
        { "id": 1, "name": "O código deve estar aberto para modificação e fechado para extensão", "alias": "a" },
        { "id": 2, "name": "O código deve estar aberto para extensão e fechado para modificação", "alias": "b" },
        { "id": 3, "name": "O código deve ser sempre público", "alias": "c" }
      ],
      "correct": "b",
      "explanation": "Classes devem estar abertas para extensão mas fechadas para modificação.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Open/Closed significa que posso adicionar novas funcionalidades sem alterar código existente. Uso interfaces e herança: criando PaymentProcessor interface, posso implementar CreditCardPayment, PayPalPayment sem modificar o código original. Quando surge novo método de pagamento, apenas crio nova implementação. Isso reduz bugs e facilita manutenção em sistemas legados."
    },
    {
      "id": 293,
      "question": "O que o princípio Liskov Substitution garante?",
      "options": [
        { "id": 1, "name": "Que subclasses possam substituir suas superclasses sem alterar o comportamento esperado", "alias": "a" },
        { "id": 2, "name": "Que todas as classes sejam abstratas", "alias": "b" },
        { "id": 3, "name": "Que métodos sejam sempre públicos", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "Objetos de subclasses devem poder substituir objetos da classe pai sem quebrar a funcionalidade.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Liskov Substitution garante que qualquer instância da classe pai pode ser substituída por instância da subclasse. Se tenho Animal e Bird extends Animal, posso usar Bird onde espero Animal. Mas se Bird sobrescreve fly() e Penguin extends Bird, Penguin não deveria ter fly() funcional. Prefiro criar Flying interface apenas para aves que voam. Isso evita quebras no polimorfismo."
    },
    {
      "id": 294,
      "question": "O que o princípio Interface Segregation recomenda?",
      "options": [
        { "id": 1, "name": "Criar interfaces grandes e genéricas", "alias": "a" },
        { "id": 2, "name": "Dividir interfaces em partes menores e mais específicas", "alias": "b" },
        { "id": 3, "name": "Evitar o uso de interfaces", "alias": "c" }
      ],
      "correct": "b",
      "explanation": "Clientes não devem depender de interfaces que não usam.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Interface Segregation evita que classes implementem métodos desnecessários. Ao invés de uma interface Worker gigante com work(), eat(), sleep(), crio interfaces específicas: Workable, Eatable, Sleepable. Robot implementa apenas Workable, Human implementa todas. Assim cada classe depende apenas do que realmente precisa, tornando o código mais flexível e fácil de manter."
    },
    {
      "id": 295,
      "question": "Qual é o foco do princípio Dependency Inversion?",
      "options": [
        { "id": 1, "name": "Depender de implementações concretas", "alias": "a" },
        { "id": 2, "name": "Depender de abstrações e não de implementações", "alias": "b" },
        { "id": 3, "name": "Evitar o uso de dependências externas", "alias": "c" }
      ],
      "correct": "b",
      "explanation": "Módulos de alto nível não devem depender de módulos de baixo nível. Ambos devem depender de abstrações.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Dependency Inversion inverte a dependência tradicional. Em vez de UserService depender diretamente de MySQLDatabase, ambos dependem de DatabaseInterface. UserService recebe a implementação via injeção de dependência. Isso permite trocar MySQL por PostgreSQL sem alterar UserService. No Angular, uso injeção de dependência nativamente: constructor(@Inject(DATABASE_TOKEN) private db: DatabaseInterface)."
    },
    {
      "id": 296,
      "question": "O que significa o acrônimo SOLID na programação orientada a objetos?",
      "options": [
        { "id": 1, "name": "Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion", "alias": "a" },
        { "id": 2, "name": "Simple Object, Logic Integration, Data", "alias": "b" },
        { "id": 3, "name": "System Optimization, Layer Isolation, Design", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "SOLID são 5 princípios fundamentais para design de software orientado a objetos.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: SOLID são princípios que aplico diariamente para criar código maintível. Single Responsibility (uma razão para mudar), Open/Closed (extensível sem modificação), Liskov Substitution (subclasses substituem pais), Interface Segregation (interfaces específicas), Dependency Inversion (depender de abstrações). Exemplo prático: ao criar UserManager, separo responsabilidades (UserValidator, UserRepository), uso interfaces para extensibilidade e injeto dependências."
    },
    {
      "id": 297,
      "question": "Por que o princípio Single Responsibility é importante?",
      "options": [
        { "id": 1, "name": "Porque permite que uma classe tenha múltiplas responsabilidades", "alias": "a" },
        { "id": 2, "name": "Porque facilita testes, manutenção e reutilização do código", "alias": "b" },
        { "id": 3, "name": "Porque reduz o número de arquivos no projeto", "alias": "c" }
      ],
      "correct": "b",
      "explanation": "Classes com única responsabilidade são mais fáceis de testar, manter e reutilizar.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Single Responsibility torna o código previsível e maintível. Uma classe OrderProcessor que processa pedidos, envia emails E calcula impostos é difícil de testar e modificar. Separando em OrderProcessor, EmailService e TaxCalculator, posso testar cada um isoladamente, reutilizar TaxCalculator em outros contextos e modificar cálculo de impostos sem afetar processamento de pedidos."
    },
    {
      "id": 298,
      "question": "Como o princípio Interface Segregation melhora o design de software?",
      "options": [
        { "id": 1, "name": "Evita que classes sejam forçadas a implementar métodos que não usam", "alias": "a" },
        { "id": 2, "name": "Permite que interfaces tenham apenas métodos privados", "alias": "b" },
        { "id": 3, "name": "Garante que todas as interfaces sejam genéricas", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "Clientes não devem ser forçados a depender de interfaces que não utilizam.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Interface Segregation evita 'fat interfaces' que forçam implementações desnecessárias. Em vez de Vehicle com fly(), swim(), drive(), crio interfaces específicas: Flyable, Swimmable, Driveable. Airplane implementa Flyable e Driveable, Boat implementa Swimmable e Driveable. Isso reduz acoplamento e torna implementações mais coesas e flexíveis."
    },
    {
      "id": 299,
      "question": "O que caracteriza uma função assíncrona em JavaScript?",
      "options": [
        { "id": 1, "name": "Ela é executada em paralelo com outras funções", "alias": "a" },
        { "id": 2, "name": "Ela retorna uma Promise e pode usar 'await' para esperar resultados", "alias": "b" },
        { "id": 3, "name": "Ela bloqueia a execução do restante do código", "alias": "c" }
      ],
      "correct": "b",
      "explanation": "Funções async retornam Promises automaticamente e permitem uso de await.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Funções async/await facilitam código assíncrono legível. Em vez de .then().catch(), uso try/catch com await. Exemplo: async function getUser() { try { const user = await api.fetchUser(); return user; } catch (error) { handleError(error); }}. Isso evita callback hell e torna o código mais limpo. Sempre implemento error handling adequado."
    },
    {
      "id": 300,
      "question": "Qual é a vantagem de usar 'await' dentro de uma função assíncrona?",
      "options": [
        { "id": 1, "name": "Permite que o código continue sem esperar a resposta", "alias": "a" },
        { "id": 2, "name": "Faz com que a função retorne imediatamente", "alias": "b" },
        { "id": 3, "name": "Suspende a execução até que a Promise seja resolvida", "alias": "c" }
      ],
      "correct": "c",
      "explanation": "await pausa a execução da função até que a Promise seja resolvida ou rejeitada.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: await torna código assíncrono similar ao síncrono, melhorando legibilidade. Posso aguardar múltiplas operações sequenciais: const user = await getUser(); const profile = await getProfile(user.id); const posts = await getPosts(user.id). Ou paralelas com Promise.all: const [user, posts] = await Promise.all([getUser(), getPosts()]). Sempre uso try/catch para tratamento de erros."
    },
    {
      "id": 301,
      "question": "O que significa o termo 'assíncrono' na programação?",
      "options": [
        { "id": 1, "name": "Que as operações ocorrem em tempo real e simultaneamente", "alias": "a" },
        { "id": 2, "name": "Que as operações podem ocorrer de forma independente, sem bloquear o fluxo principal", "alias": "b" },
        { "id": 3, "name": "Que o código é executado apenas após o carregamento completo da página", "alias": "c" }
      ],
      "correct": "b",
      "explanation": "Programação assíncrona permite que operações executem sem bloquear o thread principal.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Programação assíncrona é essencial para UX responsiva. Enquanto faço requisição à API, a interface continua interativa. Uso Promises/async-await para operações demoradas: requisições HTTP, leitura de arquivos, timers. No Angular, Observables facilitam isso: this.http.get().subscribe() não trava a UI. Event Loop do JavaScript gerencia a execução, mantendo a aplicação fluida."
    },
    {
      "id": 302,
      "question": "Qual é a principal vantagem de usar programação assíncrona?",
      "options": [
        { "id": 1, "name": "Permite que múltiplas tarefas sejam executadas sem travar o sistema", "alias": "a" },
        { "id": 2, "name": "Evita o uso de funções", "alias": "b" },
        { "id": 3, "name": "Garante que todas as tarefas sejam executadas em ordem", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "Programação assíncrona melhora responsividade e performance da aplicação.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Assíncrono evita blocking operations que travam a UI. Sem ele, uma requisição de 2 segundos congelaria toda a aplicação. Com async, posso mostrar loading spinner enquanto busco dados. Também permite paralelização: carregar dados do usuário E seus posts simultaneamente com Promise.all(). Isso melhora drasticamente a experiência do usuário."
    },
    {
      "id": 306,
      "question": "Qual é o principal objetivo da reunião diária (daily stand-up) em metodologias ágeis?",
      "options": [
        { "id": 1, "name": "Definir metas de longo prazo", "alias": "a" },
        { "id": 2, "name": "Compartilhar o progresso, identificar impedimentos e alinhar o time", "alias": "b" },
        { "id": 3, "name": "Apresentar o produto ao cliente", "alias": "c" }
      ],
      "correct": "b",
      "explanation": "Daily visa sincronização rápida do time e identificação precoce de bloqueios.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Daily é sobre transparência e colaboração. Cada membro responde: 'O que fiz ontem?', 'O que farei hoje?', 'Tenho impedimentos?'. Máximo 15 minutos, foco em sincronização, não relatório detalhado. Quando identifico impedimento, busco ajuda do time. Se alguém está trabalhando em algo similar, nos sincronizamos depois. Mantém o time alinhado e produtivo."
    },
    {
      "id": 307,
      "question": "O que acontece na reunião de planning (planejamento) em Scrum?",
      "options": [
        { "id": 1, "name": "O time define quais tarefas serão executadas no próximo sprint", "alias": "a" },
        { "id": 2, "name": "Os stakeholders aprovam o deploy em produção", "alias": "b" },
        { "id": 3, "name": "Os desenvolvedores revisam o código uns dos outros", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "Sprint Planning define o escopo e objetivos do próximo sprint.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Sprint Planning é dividido em duas partes: 'O que faremos?' e 'Como faremos?'. Product Owner apresenta prioridades do backlog, time estima complexidade usando planning poker ou t-shirt sizes. Consideramos velocity histórica para definir capacidade realista. Quebramos User Stories em tarefas técnicas menores. Definimos Definition of Done clara. Planning bem feito garante sprint focado e produtivo."
    },
    {
      "id": 308,
      "question": "Qual é o propósito da reunião de review (revisão de sprint)?",
      "options": [
        { "id": 1, "name": "Apresentar o que foi desenvolvido e coletar feedback dos stakeholders", "alias": "a" },
        { "id": 2, "name": "Revisar os testes automatizados", "alias": "b" },
        { "id": 3, "name": "Planejar o próximo trimestre", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "Sprint Review demonstra o incremento desenvolvido e coleta feedback.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Sprint Review é demo das funcionalidades entregues para stakeholders. Mostro o produto funcionando, não slides ou teorias. Coleto feedback real dos usuários, identifico ajustes necessários. PO atualiza o backlog baseado no feedback. É transparência total: mostro o que funcionou e o que não funcionou. Essa validação contínua garante que construímos o produto certo."
    },
    {
      "id": 309,
      "question": "O que é uma retrospectiva em metodologias ágeis?",
      "options": [
        { "id": 1, "name": "Uma reunião para revisar o código-fonte", "alias": "a" },
        { "id": 2, "name": "Uma reunião para refletir sobre o processo e buscar melhorias", "alias": "b" },
        { "id": 3, "name": "Uma análise de desempenho individual", "alias": "c" }
      ],
      "correct": "b",
      "explanation": "Retrospectiva foca em melhorar o processo de trabalho do time.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Retrospectiva é momento de melhoria contínua do processo. Usamos formato 'Start, Stop, Continue': o que começar a fazer, parar de fazer, continuar fazendo. Discutimos impedimentos recorrentes, celebramos sucessos, definimos ações concretas para o próximo sprint. Exemplo: identificamos que code review estava atrasando entregas, então definimos SLA de 24h para reviews. Foco sempre no processo, não nas pessoas."
    },
    {
      "id": 310,
      "question": "Qual é uma vantagem das metodologias ágeis em relação aos modelos tradicionais?",
      "options": [
        { "id": 1, "name": "Maior flexibilidade para mudanças e entregas incrementais", "alias": "a" },
        { "id": 2, "name": "Documentação extensa antes do início do projeto", "alias": "b" },
        { "id": 3, "name": "Execução linear e sem revisões", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "Agilidade permite adaptação rápida a mudanças e entrega contínua de valor.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Metodologias ágeis respondem a mudanças ao invés de seguir plano rígido. Entregamos valor incremental a cada sprint, permitindo validação contínua com usuários. Se mercado muda ou surgem novas necessidades, pivotamos rapidamente. Feedback loops curtos evitam desperdício de tempo construindo features desnecessárias. Foco em individuals e interactions over processes and tools."
    },
    {
      "id": 311,
      "question": "Qual é a principal diferença entre Scrum e Kanban?",
      "options": [
        { "id": 1, "name": "Scrum usa sprints com duração fixa; Kanban é contínuo e baseado em fluxo", "alias": "a" },
        { "id": 2, "name": "Kanban exige reuniões diárias obrigatórias", "alias": "b" },
        { "id": 3, "name": "Scrum não possui papéis definidos", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "Scrum trabalha em sprints timeboxed, enquanto Kanban é um fluxo contínuo baseado em limites WIP.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Trabalhei com ambos. Scrum é ideal quando precisa de entregas regulares e planejamento estruturado - sprints de 2 semanas com planning, daily, review e retrospectiva. Kanban uso para suporte ou manutenção, onde demandas chegam continuamente. O board Kanban limita WIP (work in progress) para evitar multitasking excessivo. Cada abordagem serve contextos diferentes."
    },
    {
      "id": 321,
      "question": "O que é um Design Pattern no contexto de desenvolvimento de software?",
      "options": [
        { "id": 1, "name": "Uma biblioteca de componentes visuais", "alias": "a" },
        { "id": 2, "name": "Uma solução reutilizável para problemas recorrentes de projeto", "alias": "b" },
        { "id": 3, "name": "Um tipo de teste automatizado", "alias": "c" }
      ],
      "correct": "b",
      "explanation": "Design Patterns são soluções testadas e documentadas para problemas comuns de design de software.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Design Patterns são como receitas de bolo - soluções comprovadas para problemas recorrentes. Por exemplo, uso Singleton para serviços que devem ter única instância (como AuthService), Observer para notificações entre componentes, Strategy para diferentes algoritmos de pagamento. Não são código, mas conceitos que tornam o sistema mais flexível e mantível. É importante não forçar padrões onde não são necessários."
    },
    {
      "id": 331,
      "question": "O que é um Observable no contexto do RxJS?",
      "options": [
        { "id": 1, "name": "Uma função que retorna um valor síncrono", "alias": "a" },
        { "id": 2, "name": "Uma abstração que representa um fluxo de dados assíncronos", "alias": "b" },
        { "id": 3, "name": "Um tipo de variável global", "alias": "c" }
      ],
      "correct": "b",
      "explanation": "Observables representam fluxos de dados que podem emitir valores ao longo do tempo.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Observable é como uma mangueira de dados - pode emitir múltiplos valores ao longo do tempo. Diferente de Promise que resolve uma vez, Observable pode emitir 0, 1 ou N valores. Uso para HTTP requests, eventos de formulário, WebSocket connections. É lazy - só executa quando subscribe. RxJS operators como map, filter, switchMap tornam o código declarativo."
    },
    {
      "id": 332,
      "question": "Qual operador RxJS é usado para transformar os valores emitidos por um Observable?",
      "options": [
        { "id": 1, "name": "map", "alias": "a" },
        { "id": 2, "name": "filter", "alias": "b" },
        { "id": 3, "name": "subscribe", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "O operador map transforma cada valor emitido aplicando uma função de transformação.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: O operador map é como Array.map(), mas para Observables. Transformo cada valor emitido: userObservable.pipe(map(user => user.name)) extrai apenas o nome. É pipeable operator, então posso encadear: .pipe(map(toUpperCase), filter(isValid)). Diferente de subscribe, map retorna novo Observable, mantendo a cadeia reativa funcional."
    },
    {
      "id": 333,
      "question": "O que o operador 'switchMap' faz em RxJS?",
      "options": [
        { "id": 1, "name": "Cancela o Observable anterior e substitui por um novo", "alias": "a" },
        { "id": 2, "name": "Combina múltiplos Observables em paralelo", "alias": "b" },
        { "id": 3, "name": "Executa todos os Observables em sequência", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "switchMap cancela a subscription anterior quando um novo valor é emitido, evitando race conditions.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: switchMap é essencial para evitar race conditions. Quando usuario digita no search input, cada keystroke dispara nova requisição. switchMap cancela requisição anterior e executa apenas a mais recente. Perfeito para autocomplete: searchInput.pipe(switchMap(term => this.api.search(term))). Evita respostas fora de ordem que confundiriam o usuário."
    },
    {
      "id": 334,
      "question": "Qual é a função do método 'subscribe' em um Observable?",
      "options": [
        { "id": 1, "name": "Encerrar o Observable", "alias": "a" },
        { "id": 2, "name": "Iniciar a execução e receber os valores emitidos", "alias": "b" },
        { "id": 3, "name": "Transformar os dados em JSON", "alias": "c" }
      ],
      "correct": "b",
      "explanation": "subscribe inicia a execução do Observable e permite receber os valores emitidos.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: subscribe é onde 'consumo' o Observable. Sem subscribe, Observable é lazy - não executa. É como ligar a torneira: observable.subscribe(data => console.log(data)). Sempre implemento error handling: .subscribe({next: data => {}, error: err => {}}). Importante: sempre unsubscribe para evitar memory leaks, uso takeUntil(destroy$) ou async pipe no template."
    },
    {
      "id": 335,
      "question": "Qual operador RxJS é ideal para executar múltiplos Observables em paralelo e aguardar todos os resultados?",
      "options": [
        { "id": 1, "name": "mergeMap", "alias": "a" },
        { "id": 2, "name": "forkJoin", "alias": "b" },
        { "id": 3, "name": "concatMap", "alias": "c" }
      ],
      "correct": "b",
      "explanation": "forkJoin aguarda que todos os Observables completem e retorna um array com todos os resultados.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: forkJoin é como Promise.all() para Observables. Executa múltiplas operações em paralelo e aguarda todas completarem: forkJoin([getUser(), getPosts(), getProfile()]).subscribe(([user, posts, profile]) => {}). Só emite quando TODOS completam. Diferente de combineLatest que emite sempre que qualquer um muda. Ideal para carregar dados independentes simultaneamente."
    },
    {
      "id": 336,
      "question": "Qual operador RxJS é usado para filtrar valores emitidos por um Observable?",
      "options": [
        { "id": 1, "name": "filter", "alias": "a" },
        { "id": 2, "name": "map", "alias": "b" },
        { "id": 3, "name": "take", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "O operador filter permite que apenas valores que atendem a uma condição passem pelo stream.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: filter funciona como Array.filter(), mas para streams. Só deixa passar valores que atendem condição: numbers$.pipe(filter(n => n > 5)). Muito útil para eventos: clicks$.pipe(filter(event => event.target.classList.contains('valid'))). Combino com outros operadores: searchInput.pipe(filter(term => term.length > 2), switchMap(term => search(term))). Evita requisições desnecessárias."
    },
    {
      "id": 337,
      "question": "O que é um Subject em RxJS?",
      "options": [
        { "id": 1, "name": "Um tipo especial de Observable que permite multicasting", "alias": "a" },
        { "id": 2, "name": "Um operador para transformar valores", "alias": "b" },
        { "id": 3, "name": "Uma função que cancela Observables", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "Subject é um tipo especial de Observable que pode ter múltiplos observers e permite emitir valores.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Subject é Observable que posso controlar - posso emitir valores com next(), complete(), error(). É multicast: vários subscribers recebem o mesmo valor. Uso para comunicação entre componentes: private messageSubject = new Subject(); sendMessage(msg) { this.messageSubject.next(msg); }. Diferente de Observable comum que é unicast e cold."
    },
    {
      "id": 338,
      "question": "Qual a diferença entre Subject e BehaviorSubject?",
      "options": [
        { "id": 1, "name": "BehaviorSubject armazena o último valor emitido e o envia aos novos inscritos", "alias": "a" },
        { "id": 2, "name": "Subject é síncrono e BehaviorSubject é assíncrono", "alias": "b" },
        { "id": 3, "name": "Subject é usado apenas em testes", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "BehaviorSubject mantém o último valor emitido e o envia imediatamente para novos subscribers.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: BehaviorSubject guarda o último valor emitido. Novo subscriber recebe imediatamente o valor atual. Ideal para estados: private userSubject = new BehaviorSubject(null); get currentUser() { return this.userSubject.value; }. Subject comum não guarda nada - subscriber só recebe valores futuros. BehaviorSubject requer valor inicial, Subject não."
    },
    {
      "id": 339,
      "question": "Qual operador RxJS é usado para limitar a quantidade de valores emitidos?",
      "options": [
        { "id": 1, "name": "take", "alias": "a" },
        { "id": 2, "name": "merge", "alias": "b" },
        { "id": 3, "name": "scan", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "O operador take limita a quantidade de valores que o Observable pode emitir.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: take(n) pega apenas os primeiros n valores e completa o Observable automaticamente. Exemplo: interval(1000).pipe(take(3)) emite 0, 1, 2 e para. Muito útil: take(1) para single value como getCurrentUser(), takeUntil(destroy$) para auto-unsubscribe em componentes. takeWhile(condition) para parar baseado em condição."
    },
    {
      "id": 340,
      "question": "Por que usar RxJS em aplicações Angular?",
      "options": [
        { "id": 1, "name": "Para manipular fluxos assíncronos como eventos, requisições HTTP e formulários reativos", "alias": "a" },
        { "id": 2, "name": "Para substituir o roteamento padrão", "alias": "b" },
        { "id": 3, "name": "Para estilizar componentes com CSS", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "RxJS facilita o manejo de operações assíncronas e fluxos de dados complexos em Angular.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: RxJS é coração do Angular - HttpClient retorna Observables, Reactive Forms usam Observables, eventos são streams. Permite programação declarativa: combino streams, transformo dados, reajo a mudanças. Exemplo: combineLatest([searchTerm$, filters$]).pipe(switchMap(([term, filters]) => search(term, filters))). Gerencia estado complexo, evita callback hell, facilita cancelamento de operações."
    },
    {
      "id": 342,
      "question": "Qual é o principal benefício do lazy loading em aplicações Angular?",
      "options": [
        { "id": 1, "name": "Reduz o tempo de carregamento inicial da aplicação", "alias": "a" },
        { "id": 2, "name": "Aumenta o tamanho do bundle principal", "alias": "b" },
        { "id": 3, "name": "Impede a reutilização de componentes", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "Lazy loading reduz o bundle inicial carregando módulos apenas quando necessário.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Lazy loading melhora drasticamente Time to Interactive (TTI). Bundle inicial menor significa carregamento mais rápido, especialmente em redes 3G. Usuário vê a página principal rapidamente, módulos de admin/settings carregam só quando necessário. Implemento code splitting automático: { path: 'admin', loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule) }. Estratégia essencial para Progressive Web Apps."
    },
    {
      "id": 343,
      "question": "Como o lazy loading é implementado em Angular?",
      "options": [
        { "id": 1, "name": "Utilizando o operador 'subscribe' em Observables", "alias": "a" },
        { "id": 2, "name": "Configurando rotas com 'loadChildren' no módulo de roteamento", "alias": "b" },
        { "id": 3, "name": "Importando todos os módulos no AppModule", "alias": "c" }
      ],
      "correct": "b",
      "explanation": "Lazy loading em Angular é configurado nas rotas usando a propriedade loadChildren.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Uso loadChildren nas rotas para carregar módulos sob demanda. Sintaxe moderna: loadChildren: () => import('./feature/feature.module').then(m => m.FeatureModule). Angular automaticamente cria chunk separado para cada módulo lazy. Posso usar preloading strategies para otimizar: RouterModule.forRoot(routes, {preloadingStrategy: PreloadAllModules}) pré-carrega módulos em background após carregamento inicial."
    },
    {
      "id": 344,
      "question": "Lazy loading pode ser aplicado a quais tipos de recursos?",
      "options": [
        { "id": 1, "name": "Imagens, módulos, componentes e scripts", "alias": "a" },
        { "id": 2, "name": "Apenas arquivos de áudio", "alias": "b" },
        { "id": 3, "name": "Somente estilos CSS", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "Lazy loading pode ser aplicado a diversos tipos de recursos para otimizar performance.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Implemento lazy loading em múltiplas camadas: 1) Módulos Angular com loadChildren, 2) Imagens com Intersection Observer API ou loading='lazy', 3) Componentes standalone com dynamic imports, 4) Scripts externos carregados condicionalmente. Exemplo: só carrego Google Maps SDK quando usuário abre mapa. Estratégia holística reduz bundle inicial e melhora Core Web Vitals."
    },
    {
      "id": 345,
      "question": "Qual prática pode complementar o lazy loading para melhorar a performance?",
      "options": [
        { "id": 1, "name": "Pré-carregamento seletivo (preloading)", "alias": "a" },
        { "id": 2, "name": "Desativar cache do navegador", "alias": "b" },
        { "id": 3, "name": "Carregar todos os scripts no head", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "Preloading strategies permitem carregar módulos em background após o carregamento inicial.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Combino lazy loading com preloading inteligente. PreloadAllModules carrega módulos em background após inicial load. Ou implemento custom strategy: só pré-carrego módulos que usuário provavelmente acessará baseado em analytics. Uso service worker para cache inteligente. Resource hints como <link rel='prefetch'> para recursos futuros. Estratégia balanceada entre performance inicial e UX fluida."
    },
    {
      "id": 346,
      "question": "O que significa uma arquitetura modular em projetos de software?",
      "options": [
        { "id": 1, "name": "Separar o código em partes independentes e reutilizáveis", "alias": "a" },
        { "id": 2, "name": "Agrupar todo o código em um único arquivo", "alias": "b" },
        { "id": 3, "name": "Evitar o uso de componentes reutilizáveis", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "Arquitetura modular divide o sistema em módulos independentes com responsabilidades bem definidas.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Arquitetura modular é como LEGO - peças independentes que se conectam. Cada módulo tem responsabilidade única, interface clara, baixo acoplamento. No Angular: Core module (singleton services), Shared module (componentes reutilizáveis), Feature modules (funcionalidades específicas). Benefícios: facilita testes, manutenção, trabalho em equipe, lazy loading. Exemplo: AuthModule, ProductModule, OrderModule - cada um independente mas interconectado via interfaces."
    },
    {
      "id": 347,
      "question": "Qual é uma vantagem de organizar um projeto Angular em módulos feature-based?",
      "options": [
        { "id": 1, "name": "Facilita o lazy loading e a manutenção do código", "alias": "a" },
        { "id": 2, "name": "Aumenta o tempo de build", "alias": "b" },
        { "id": 3, "name": "Impede a reutilização de componentes", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "Módulos feature-based permitem lazy loading e melhor organização do código por funcionalidades.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Feature-based modules organizam código por funcionalidade de negócio, não por tipo técnico. Em vez de 'components/', 'services/', tenho 'user-management/', 'product-catalog/'. Cada feature é mini-aplicação: seus componentes, services, models. Facilita lazy loading, onboarding de novos devs, manutenção. Time de produtos trabalha só no ProductModule sem afetar UserModule. Escalabilidade real."
    },
    {
      "id": 348,
      "question": "Como a separação de responsabilidades contribui para a escalabilidade de um projeto?",
      "options": [
        { "id": 1, "name": "Permite que diferentes partes do sistema evoluam de forma independente", "alias": "a" },
        { "id": 2, "name": "Centraliza toda a lógica em um único módulo", "alias": "b" },
        { "id": 3, "name": "Reduz a necessidade de testes", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "Separação de responsabilidades reduz acoplamento, facilitando evolução independente de módulos.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Separação de responsabilidades é chave para escalabilidade. Cada módulo/component tem função clara, reduzindo dependências. Exemplo: AuthService só cuida de autenticação, UserService só de dados do usuário. Se preciso mudar lógica de autenticação, faço no AuthService sem afetar UserService. Facilita trabalho em equipe - múltiplos devs podem trabalhar em módulos diferentes simultaneamente. Testes unitários mais simples e eficazes."
    },
    {
      "id": 349,
      "question": "Qual prática ajuda a manter um projeto escalável ao longo do tempo?",
      "options": [
        { "id": 1, "name": "Evitar documentação e testes", "alias": "a" },
        { "id": 2, "name": "Adotar padrões consistentes de arquitetura e modularização", "alias": "b" },
        { "id": 3, "name": "Manter todos os arquivos em uma única pasta", "alias": "c" }
      ],
      "correct": "b",
      "explanation": "Padrões consistentes facilitam manutenção, onboarding e evolução do projeto.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Adotar padrões consistentes é crucial para a escalabilidade. Isso inclui convenções de nomenclatura, estrutura de pastas e práticas de codificação. Por exemplo, usar sempre 'feature/' para módulos de recursos e 'shared/' para módulos compartilhados. Isso ajuda novos desenvolvedores a entenderem rapidamente a estrutura do projeto e reduz a curva de aprendizado."
    },
    {
      "id": 350,
      "question": "Em projetos escaláveis, o que é recomendado ao lidar com dependências entre módulos?",
      "options": [
        { "id": 1, "name": "Evitar acoplamento excessivo e usar interfaces ou serviços compartilhados", "alias": "a" },
        { "id": 2, "name": "Importar diretamente componentes de outros módulos", "alias": "b" },
        { "id": 3, "name": "Duplicar código para evitar dependências", "alias": "c" }
      ],
      "correct": "a",
      "explanation": "Reduzir acoplamento entre módulos facilita manutenção e evolução independente.",
      "category": "entrevista",
      "interviewTip": "Como explicar na entrevista: Para lidar com dependências entre módulos, é importante evitar acoplamento excessivo. Isso pode ser feito usando interfaces ou serviços compartilhados. Por exemplo, em vez de um módulo importar diretamente componentes de outro, ele pode se comunicar através de um serviço. Isso torna os módulos mais independentes e facilita a manutenção."
    },
    {
  "id": 351,
  "question": "O que é TypeScript e quais suas principais vantagens?",
  "options": [
    { "id": 1, "name": "É um superset do JavaScript que adiciona tipagem estática", "alias": "a" },
    { "id": 2, "name": "É um framework para desenvolvimento web", "alias": "b" },
    { "id": 3, "name": "É uma biblioteca para manipulação do DOM", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "TypeScript adiciona tipagem estática ao JavaScript, melhorando detecção de erros e IntelliSense.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: TypeScript é JavaScript com superpoderes. Adiciona tipagem estática que detecta erros em tempo de compilação, não runtime. Melhora drasticamente a experiência de desenvolvimento com IntelliSense, refactoring seguro e documentação self-describing. Em projetos grandes, reduz bugs significativamente. É transpilado para JavaScript puro, então roda em qualquer lugar que JS roda."
},
{
  "id": 352,
  "question": "O que são Web Components e qual sua importância?",
  "options": [
    { "id": 1, "name": "Conjunto de tecnologias para criar elementos HTML personalizados e reutilizáveis", "alias": "a" },
    { "id": 2, "name": "Uma biblioteca JavaScript para animações", "alias": "b" },
    { "id": 3, "name": "Um framework para desenvolvimento backend", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Web Components permitem criar elementos HTML customizados usando Custom Elements, Shadow DOM e HTML Templates.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Web Components são padrão web nativo para criar componentes reutilizáveis sem frameworks. Uso Custom Elements para definir tags personalizadas, Shadow DOM para encapsular estilos e funcionalidade, HTML Templates para markup reutilizável. Exemplo: <my-button disabled>Click me</my-button>. Funciona em todos os browsers modernos e é framework-agnostic. Ideal para design systems e componentes compartilhados entre diferentes projetos."
},
{
  "id": 353,
  "question": "Como você implementaria autenticação em uma SPA (Single Page Application)?",
  "options": [
    { "id": 1, "name": "Usando JWT tokens e guards de rota", "alias": "a" },
    { "id": 2, "name": "Apenas com cookies de sessão", "alias": "b" },
    { "id": 3, "name": "Armazenando senhas no localStorage", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "JWT tokens com guards de rota fornecem autenticação stateless e segura em SPAs.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Implemento autenticação com JWT tokens: 1) Login envia credenciais para API que retorna access token + refresh token, 2) Armazeno tokens de forma segura (httpOnly cookies ou memória), 3) AuthGuard intercepta rotas protegidas verificando token válido, 4) AuthInterceptor adiciona token automaticamente às requisições HTTP, 5) Refresh token strategy para renovar tokens expirados. Para segurança extra, uso HTTPS always e implemento logout automático."
},
{
  "id": 354,
  "question": "O que é Progressive Web App (PWA) e suas principais características?",
  "options": [
    { "id": 1, "name": "App web que funciona offline e pode ser instalada como app nativo", "alias": "a" },
    { "id": 2, "name": "Uma biblioteca para desenvolvimento web", "alias": "b" },
    { "id": 3, "name": "Um tipo de banco de dados", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "PWAs combinam o melhor da web e apps nativos com service workers, manifests e design responsivo.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: PWA combina web e mobile nativo. Características principais: 1) Service Worker para cache e funcionamento offline, 2) Web App Manifest para instalação no device, 3) HTTPS obrigatório para segurança, 4) Design responsivo e touch-friendly, 5) Push notifications para engagement. Vantagens: sem app store, updates automáticos, menor tamanho que apps nativos. Desenvolvo PWAs usando Angular Service Worker que automatiza cache strategies."
},
{
  "id": 355,
  "question": "Como você otimizaria a performance de uma aplicação web?",
  "options": [
    { "id": 1, "name": "Code splitting, lazy loading, otimização de imagens e cache strategies", "alias": "a" },
    { "id": 2, "name": "Apenas usando CDN para assets", "alias": "b" },
    { "id": 3, "name": "Minificando apenas o CSS", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Performance requer abordagem holística: code splitting, lazy loading, otimização de assets e cache inteligente.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Performance é multi-layered: 1) Bundle optimization com code splitting e tree shaking, 2) Lazy loading de módulos e imagens, 3) Otimização de assets (WebP images, minificação), 4) HTTP/2 e preload critical resources, 5) Service Worker para cache strategies, 6) Database optimization e CDN para assets. Uso Lighthouse para medir Core Web Vitals. Monitoro com ferramentas como New Relic ou DataDog em produção."
},
{
  "id": 356,
  "question": "O que é Docker e como você o usaria em desenvolvimento front-end?",
  "options": [
    { "id": 1, "name": "Plataforma de containerização para padronizar ambientes de desenvolvimento", "alias": "a" },
    { "id": 2, "name": "Uma linguagem de programação para backend", "alias": "b" },
    { "id": 3, "name": "Um framework JavaScript", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Docker containeriza aplicações garantindo consistência entre ambientes de desenvolvimento, teste e produção.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Docker resolve o problema 'funciona na minha máquina'. Crio Dockerfile que define ambiente padronizado com Node.js, dependências e configurações. docker-compose orquestra múltiplos containers (frontend, backend, banco). Vantagens: 1) Ambiente consistente entre devs, 2) Onboarding rápido de novos membros, 3) Deploy idêntico em staging/produção, 4) Isolamento de dependências. Uso multi-stage builds para otimizar imagens de produção."
},
{
  "id": 357,
  "question": "Como você implementaria um sistema de estado global sem Redux/NgRx?",
  "options": [
    { "id": 1, "name": "Usando Context API no React ou Services com BehaviorSubject no Angular", "alias": "a" },
    { "id": 2, "name": "Apenas com variáveis globais", "alias": "b" },
    { "id": 3, "name": "Usando apenas localStorage", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Context API e Services com RxJS fornecem state management simples sem bibliotecas externas.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Para estado global simples, uso ferramentas nativas: Context API no React ou Services singleton no Angular. Crio UserService com BehaviorSubject para estado reativo: private userSubject = new BehaviorSubject(null); get user$() { return this.userSubject.asObservable(); }. Para estado complexo, avalio se realmente preciso de Redux/NgRx ou se padrão simples resolve. Às vezes, lift state up ou prop drilling é mais simples que over-engineering."
},
{
  "id": 358,
  "question": "O que são microfrontends e quando você os recomendaria?",
  "options": [
    { "id": 1, "name": "Arquitetura que divide frontend em módulos independentes desenvolvidos por times diferentes", "alias": "a" },
    { "id": 2, "name": "Uma nova versão do Angular", "alias": "b" },
    { "id": 3, "name": "Um tipo de componente React", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Microfrontends aplicam conceitos de microservices ao frontend, permitindo desenvolvimento independente por múltiplos times.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Microfrontends estendem microservices para frontend. Cada time desenvolve parte da aplicação independentemente - diferentes frameworks, deploy cycles, ownership. Recomendo para: 1) Times grandes (50+ devs), 2) Produtos complexos com domínios bem definidos, 3) Legacy migration gradual. Desafios: state sharing, styling consistency, bundle size. Uso Module Federation ou Single-SPA para implementar. Não recomendo para apps pequenas - overhead não compensa."
},
{
  "id": 359,
  "question": "Como você garantiria acessibilidade (a11y) em suas aplicações?",
  "options": [
    { "id": 1, "name": "Usando ARIA labels, navegação por teclado, contraste adequado e testes automatizados", "alias": "a" },
    { "id": 2, "name": "Apenas testando em diferentes navegadores", "alias": "b" },
    { "id": 3, "name": "Usando apenas cores para indicar estados", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Acessibilidade requer ARIA, navegação por teclado, contraste visual adequado e testes com screen readers.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Acessibilidade é responsabilidade, não opcional. Implemento: 1) ARIA labels e roles para screen readers, 2) Navegação completa por teclado (tab order lógico), 3) Contraste mínimo 4.5:1 para texto, 4) Focus indicators visíveis, 5) Alt text em imagens, 6) Formulários com labels associadas. Uso ferramentas como axe-core para testes automatizados e testo com NVDA/JAWS. Objetivo: app usável por todos, independente de limitações."
},
{
  "id": 360,
  "question": "O que é Server-Side Rendering (SSR) e suas vantagens?",
  "options": [
    { "id": 1, "name": "Renderização no servidor que melhora SEO e tempo de carregamento inicial", "alias": "a" },
    { "id": 2, "name": "Uma técnica apenas para aplicações mobile", "alias": "b" },
    { "id": 3, "name": "Um tipo de banco de dados", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "SSR renderiza páginas no servidor, enviando HTML completo para o cliente, melhorando SEO e performance inicial.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: SSR renderiza HTML no servidor antes de enviar para cliente. Vantagens: 1) SEO melhorado - crawlers veem conteúdo completo, 2) First Contentful Paint mais rápido, 3) Melhor performance em dispositivos lentos. Desafios: complexidade do setup, hydration mismatches, maior carga no servidor. No Angular uso Angular Universal, no React uso Next.js. Para apps com muito conteúdo dinâmico, avalio se SSG (Static Site Generation) não seria melhor."
},
{
  "id": 361,
  "question": "Como você implementaria um sistema de cache eficiente no frontend?",
  "options": [
    { "id": 1, "name": "Combinando HTTP cache, Service Workers e estratégias de invalidação", "alias": "a" },
    { "id": 2, "name": "Apenas usando localStorage para tudo", "alias": "b" },
    { "id": 3, "name": "Desabilitando cache completamente", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Cache eficiente combina múltiplas estratégias: HTTP headers, Service Workers e invalidação inteligente.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Cache multi-layered: 1) HTTP cache com ETags e Cache-Control headers para assets estáticos, 2) Service Worker para cache programático - Cache First para assets, Network First para dados dinâmicos, 3) Memory cache para dados frequentemente acessados (usando Map ou WeakMap), 4) IndexedDB para dados grandes offline-first. Estratégias de invalidação baseadas em TTL, versioning ou manual trigger. Sempre considero cache size limits e cleanup policies."
},
{
  "id": 362,
  "question": "O que são Design Tokens e como implementá-los?",
  "options": [
    { "id": 1, "name": "Valores de design armazenados como dados estruturados para consistência visual", "alias": "a" },
    { "id": 2, "name": "Uma biblioteca de componentes UI", "alias": "b" },
    { "id": 3, "name": "Um tipo de animação CSS", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Design Tokens são valores de design (cores, tipografia, espaçamentos) armazenados como dados para garantir consistência.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Design Tokens centralizam decisões de design como dados estruturados. Define cores, tipografia, spacing, shadows em JSON/YAML, depois gero variáveis CSS, SCSS, JS automaticamente. Benefícios: 1) Single source of truth para design, 2) Consistência entre plataformas (web, mobile, desktop), 3) Facilita temas e white-labeling, 4) Integração design-dev mais fluida. Uso tools como Style Dictionary ou Figma Tokens Studio para automatizar pipeline."
},
{
  "id": 363,
  "question": "Como você debuggaria problemas de performance em uma aplicação web?",
  "options": [
    { "id": 1, "name": "Usando DevTools, Lighthouse, profiling e monitoring em produção", "alias": "a" },
    { "id": 2, "name": "Apenas adicionando console.log no código", "alias": "b" },
    { "id": 3, "name": "Reescrevendo toda a aplicação", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Debug de performance requer ferramentas específicas para identificar gargalos e métricas de user experience.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Debug performance é sistemático: 1) Chrome DevTools Performance tab para identificar long tasks e layout thrashing, 2) Lighthouse para Core Web Vitals e sugestões automatizadas, 3) Network tab para analisar waterfall de requests, 4) Memory tab para detectar memory leaks, 5) Angular DevTools ou React Profiler para component re-renders, 6) Real User Monitoring (RUM) em produção. Foco em métricas que impactam UX: FCP, LCP, FID, CLS."
},
{
  "id": 364,
  "question": "O que é Webpack e qual sua importância no desenvolvimento moderno?",
  "options": [
    { "id": 1, "name": "Bundler que processa e otimiza assets para produção", "alias": "a" },
    { "id": 2, "name": "Um framework para desenvolvimento web", "alias": "b" },
    { "id": 3, "name": "Uma biblioteca para manipulação DOM", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Webpack é module bundler que processa JavaScript, CSS, imagens e outros assets para criar bundles otimizados.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Webpack orquestra todo build process moderno. Transforma código ES6+ via Babel, processa SCSS para CSS, otimiza imagens, faz code splitting automático, tree shaking para remover código morto. Conceitos principais: Entry points, Loaders (transformam arquivos), Plugins (fazem otimizações), Output configuration. Configuro dev server com hot reload, production builds com minificação e chunking. Webpack é base do Angular CLI e Create React App."
},
{
  "id": 365,
  "question": "Como você implementaria internacionalização (i18n) em uma aplicação?",
  "options": [
    { "id": 1, "name": "Usando bibliotecas como Angular i18n ou react-i18next com arquivos de tradução", "alias": "a" },
    { "id": 2, "name": "Apenas usando condicionais para mostrar textos diferentes", "alias": "b" },
    { "id": 3, "name": "Criando versões separadas da aplicação para cada idioma", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "i18n requer bibliotecas especializadas, arquivos de tradução estruturados e considerações de UX para diferentes culturas.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: i18n vai além de traduzir textos. Implemento: 1) Extraction de strings para arquivos JSON/XML de tradução, 2) Pluralization rules para diferentes idiomas, 3) Date/number/currency formatting por locale, 4) RTL support para árabe/hebraico, 5) Dynamic loading de bundles por idioma para reduzir bundle size. No Angular uso Angular i18n oficial, no React prefiro react-i18next. Considero cultural differences (cores, ícones, layout) além da linguagem."
},
{
  "id": 366,
  "question": "O que são Web APIs modernas e como você as utiliza?",
  "options": [
    { "id": 1, "name": "APIs nativas do browser como Intersection Observer, Web Workers e Payment Request", "alias": "a" },
    { "id": 2, "name": "Apenas APIs REST para comunicação com servidor", "alias": "b" },
    { "id": 3, "name": "Bibliotecas JavaScript externas", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Web APIs modernas fornecem funcionalidades nativas do browser sem necessidade de bibliotecas externas.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Web APIs modernas substituem bibliotecas pesadas por funcionalidades nativas. Uso: 1) Intersection Observer para lazy loading em vez de scroll listeners, 2) Web Workers para heavy computations sem bloquear UI, 3) Payment Request API para checkout simplificado, 4) Web Share API para share nativo, 5) Geolocation API para localização, 6) Push API para notificações. Sempre verifico browser support com caniuse.com e implemento progressive enhancement com feature detection."
},
{
  "id": 367,
  "question": "Como você estruturaria um projeto Angular/React grande com múltiplos desenvolvedores?",
  "options": [
    { "id": 1, "name": "Arquitetura baseada em features, style guides, linting automatizado e code reviews", "alias": "a" },
    { "id": 2, "name": "Uma única pasta com todos os arquivos", "alias": "b" },
    { "id": 3, "name": "Separação apenas por tipo de arquivo", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Projetos grandes requerem arquitetura bem definida, padrões consistentes e automação para manter qualidade.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Estrutura por domínio/feature, não por tipo técnico. Organização: shared/ (components/services reutilizáveis), core/ (singletons/guards), features/ (módulos por domínio), assets/, environments/. Padronização: ESLint+Prettier+Husky para code quality automática, Angular/React style guides, naming conventions claras. Workflow: feature branches, PR templates, code review obrigatório, automated testing. Documentation: README detalhado, architectural decision records (ADRs), component documentation."
},
{
  "id": 368,
  "question": "O que é GraphQL e quando você escolheria sobre REST?",
  "options": [
    { "id": 1, "name": "Query language que permite requisitar dados específicos, ideal para clientes com necessidades diferentes", "alias": "a" },
    { "id": 2, "name": "Um banco de dados NoSQL", "alias": "b" },
    { "id": 3, "name": "Uma biblioteca para animações", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "GraphQL permite queries flexíveis e tipadas, reduzindo over-fetching e under-fetching de dados.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: GraphQL resolve problemas de REST: over-fetching (dados desnecessários) e under-fetching (múltiplas requests). Com GraphQL, client especifica exatamente quais dados quer: { user { name posts { title } } }. Vantagens: 1) Strong typing com schema, 2) Single endpoint, 3) Real-time com subscriptions, 4) Great developer experience. Escolho GraphQL para: mobile apps (bandwidth limitado), complex relationships, rapid iteration. Uso Apollo Client para caching inteligente e state management."
},
{
  "id": 369,
  "question": "Como você implementaria testes end-to-end (E2E) em uma aplicação?",
  "options": [
    { "id": 1, "name": "Usando ferramentas como Cypress ou Playwright para simular interações do usuário", "alias": "a" },
    { "id": 2, "name": "Apenas com testes unitários", "alias": "b" },
    { "id": 3, "name": "Testando manualmente toda a aplicação", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Testes E2E automatizam fluxos de usuário completos, validando integração entre todos os componentes.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: E2E tests validam user journeys completos - login, navegação, forms, checkout. Uso Cypress para sintaxe simples e debugging visual, ou Playwright para cross-browser testing. Estratégia: 1) Test critical paths primeiro (happy flows), 2) Page Object Model para maintainability, 3) Data setup/teardown automático, 4) Screenshots/videos para debug, 5) Parallel execution para speed. Integro no CI/CD pipeline mas com cuidado - E2E tests são mais flaky que unit tests."
},
{
  "id": 370,
  "question": "O que é Clean Code e quais são seus princípios fundamentais?",
  "options": [
    { "id": 1, "name": "Código legível, simples e facilmente mantível seguindo princípios como DRY, YAGNI e KISS", "alias": "a" },
    { "id": 2, "name": "Código sem comentários", "alias": "b" },
    { "id": 3, "name": "Código com máxima performance", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Clean Code prioriza legibilidade, simplicidade e manutenibilidade sobre cleverness ou performance prematura.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Clean Code é sobre comunicação entre desenvolvedores. Princípios: 1) Meaningful names (getUserById vs get), 2) Functions should be small and do one thing, 3) Comments explain WHY, not WHAT, 4) DRY (Don't Repeat Yourself), 5) YAGNI (You Aren't Gonna Need It), 6) Consistent formatting. Refactoro constantemente: Extract Method, Rename Variable, Remove Dead Code. Código limpo é investimento - tempo inicial extra, mas economia gigante na manutenção."
},
{
  "id": 371,
  "question": "Como você implementaria um sistema de notificações em tempo real?",
  "options": [
    { "id": 1, "name": "Usando WebSockets ou Server-Sent Events com fallback para polling", "alias": "a" },
    { "id": 2, "name": "Apenas com requisições HTTP a cada segundo", "alias": "b" },
    { "id": 3, "name": "Usando apenas localStorage", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Notificações em tempo real requerem conexão persistente via WebSockets ou SSE, com polling como fallback.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Real-time notifications precisam de conexão persistente. WebSockets para comunicação bidirecional (chat, collaborative editing), Server-Sent Events para unidirecional (notificações). Implemento: 1) Connection management com reconnection logic, 2) Heartbeat/keepalive para detectar connection drops, 3) Message queuing para offline scenarios, 4) Progressive enhancement - polling fallback para browsers antigos. Uso libraries como Socket.io ou native WebSocket API com proper error handling."
},
{
  "id": 372,
  "question": "O que são Custom Hooks no React ou Custom Decorators no Angular?",
  "options": [
    { "id": 1, "name": "Funcionalidades reutilizáveis que encapsulam lógica complexa", "alias": "a" },
    { "id": 2, "name": "Apenas funções normais de JavaScript", "alias": "b" },
    { "id": 3, "name": "Componentes visuais customizados", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Custom Hooks/Decorators permitem reutilizar lógica stateful entre componentes de forma elegante.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Custom Hooks (React) ou Custom Decorators (Angular) extraem lógica reutilizável. React Hook exemplo: useLocalStorage que synca state com localStorage automaticamente. Angular Decorator exemplo: @Debounce que adiciona debouncing a qualquer método. Benefícios: 1) DRY principle, 2) Separation of concerns, 3) Easy testing, 4) Better composition. Sempre penso: 'essa lógica pode ser útil em outros componentes?' Se sim, extraio para custom hook/decorator."
},
{
  "id": 373,
  "question": "Como você otimizaria imagens para web considerando diferentes dispositivos?",
  "options": [
    { "id": 1, "name": "Usando formatos modernos, responsive images e lazy loading", "alias": "a" },
    { "id": 2, "name": "Apenas convertendo todas para JPEG", "alias": "b" },
    { "id": 3, "name": "Usando sempre o maior tamanho possível", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Otimização de imagens requer múltiplas estratégias: formatos modernos, sizes adequados e carregamento otimizado.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Image optimization é crucial para performance. Estratégia: 1) Formatos modernos: WebP/AVIF com JPEG fallback using <picture> element, 2) Responsive images com srcset para diferentes densidades/sizes, 3) Lazy loading com Intersection Observer ou loading='lazy', 4) CDN com automatic optimization (Cloudinary, ImageKit), 5) Build-time optimization com tools como sharp. Para arte use PNG, fotos use JPEG/WebP, ícones use SVG. Always consider CLS (Cumulative Layout Shift)."
},
{
  "id": 374,
  "question": "O que é Continuous Integration e como implementá-la?",
  "options": [
    { "id": 1, "name": "Prática de integrar código frequentemente com testes automatizados", "alias": "a" },
    { "id": 2, "name": "Deploy manual em produção", "alias": "b" },
    { "id": 3, "name": "Backup diário do código", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "CI automatiza integração de código com execução de testes, build e verificações de qualidade a cada commit.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: CI automatiza quality gates para cada commit. Pipeline típico: 1) Code push triggers build, 2) Install dependencies, 3) Run linting/formatting checks, 4) Execute unit tests com coverage, 5) Run integration tests, 6) Build for production, 7) Deploy to staging environment. Uso GitHub Actions ou GitLab CI com cache para speed up builds. Fail fast principle - se qualquer step falha, pipeline para. Team nunca deveria quebrar main branch."
},
{
  "id": 375,
  "question": "Como você implementaria um sistema de busca eficiente no frontend?",
  "options": [
    { "id": 1, "name": "Debouncing, cache de resultados, paginação e filtros avançados", "alias": "a" },
    { "id": 2, "name": "Apenas uma requisição por caractere digitado", "alias": "b" },
    { "id": 3, "name": "Carregando todos os dados na memória", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Sistema de busca eficiente requer otimizações de UX e performance: debouncing, cache e paginação.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Search UX eficiente combina várias técnicas: 1) Debouncing (300-500ms) para evitar requests excessivas, 2) Cache de resultados para queries repetidas, 3) Infinite scrolling ou pagination para large datasets, 4) Loading states e skeleton screens, 5) Search suggestions/autocomplete, 6) Advanced filters com query string persistence, 7) Search analytics para melhorar relevância. Uso RxJS switchMap para cancelar requests obsoletas. Performance critical em mobile."
},
{
  "id": 376,
  "question": "O que é Atomic Design e como aplicá-lo no desenvolvimento?",
  "options": [
    { "id": 1, "name": "Metodologia que organiza componentes UI em hierarquia: átomos, moléculas, organismos", "alias": "a" },
    { "id": 2, "name": "Uma biblioteca de animações CSS", "alias": "b" },
    { "id": 3, "name": "Um framework JavaScript", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Atomic Design estrutura design systems em componentes hierárquicos, facilitando reutilização e consistência.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Atomic Design organiza UI components sistematicamente. Átomos: button, input, label (básicos). Moléculas: search form (átomos combinados). Organismos: header, product list (moléculas + átomos). Templates: page layouts sem conteúdo. Pages: templates com dados reais. Benefícios: 1) Reusabilidade máxima, 2) Consistency across app, 3) Better developer handoff, 4) Easier testing. Uso Storybook para documentar cada nível e visualizar todas as variações."
},
{
  "id": 377,
  "question": "Como você implementaria autenticação com OAuth 2.0/OpenID Connect?",
  "options": [
    { "id": 1, "name": "Redirecionando para provider, recebendo authorization code e trocando por tokens", "alias": "a" },
    { "id": 2, "name": "Enviando credenciais diretamente para o provider", "alias": "b" },
    { "id": 3, "name": "Armazenando senhas no banco de dados local", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "OAuth 2.0 flow envolve redirecionamento para authorization server, code exchange e token management.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: OAuth 2.0 é delegation protocol - user autoriza app a acessar recursos sem compartilhar senha. Authorization Code Flow: 1) Redirect user para authorization server (Google, Auth0), 2) User consente e retorna com authorization code, 3) Exchange code por access_token + refresh_token, 4) Use tokens para API calls. PKCE (Proof Key for Code Exchange) para SPAs. OpenID Connect adiciona ID token com user info. Implemento com libraries como oauth2-client ou auth0-js."
},
{
  "id": 378,
  "question": "O que são Web Standards e por que são importantes?",
  "options": [
    { "id": 1, "name": "Especificações técnicas que garantem interoperabilidade entre browsers e plataformas", "alias": "a" },
    { "id": 2, "name": "Padrões visuais para design", "alias": "b" },
    { "id": 3, "name": "Bibliotecas JavaScript obrigatórias", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Web Standards (W3C, WHATWG) definem como tecnologias web devem funcionar, garantindo consistência cross-browser.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Web Standards garantem que web funcione igual everywhere. W3C e WHATWG definem HTML, CSS, JavaScript APIs. Importância: 1) Cross-browser compatibility, 2) Future-proof code, 3) Accessibility compliance, 4) Performance optimization. Sempre prefiro soluções standards-based: Custom Elements over proprietary widgets, CSS Grid over framework-specific layouts, Fetch API over jQuery.ajax. Progressive enhancement com feature detection quando preciso usar features cutting-edge."
},
{
  "id": 379,
  "question": "Como você implementaria um sistema de logs e monitoring no frontend?",
  "options": [
    { "id": 1, "name": "Error boundaries, structured logging, analytics e monitoring de performance", "alias": "a" },
    { "id": 2, "name": "Apenas console.log em desenvolvimento", "alias": "b" },
    { "id": 3, "name": "Alertas por email para cada erro", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Monitoring frontend requer captura de erros, métricas de performance e insights de uso para debugging e otimização.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Frontend monitoring é crucial para production apps. Implemento: 1) Error Boundaries (React) ou Global Error Handler para capturar unhandled errors, 2) Structured logging com context (user ID, route, timestamp), 3) Performance monitoring (Core Web Vitals, custom metrics), 4) User analytics (feature usage, conversion funnels). Uso tools como Sentry para error tracking, LogRocket para session replay, Google Analytics para user behavior. Always respect privacy - anonymize sensitive data."
},
{
  "id": 380,
  "question": "O que é Feature Flags e como implementá-las no frontend?",
  "options": [
    { "id": 1, "name": "Toggles que permitem ativar/desativar funcionalidades sem deploy", "alias": "a" },
    { "id": 2, "name": "Comentários especiais no código", "alias": "b" },
    { "id": 3, "name": "Configurações de CSS", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Feature Flags permitem controlar funcionalidades dinamicamente, facilitando deploys seguros e A/B testing.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Feature Flags (ou Feature Toggles) permitem deployar código disabled e ativar remotamente. Use cases: 1) Gradual rollouts (5% → 50% → 100%), 2) A/B testing different implementations, 3) Kill switch para features problemáticas, 4) Trunk-based development sem feature branches. Implementação: flag service que busca configurações remotas, components que checam flags antes de render. Uso LaunchDarkly ou custom solution com real-time updates via WebSocket."
},
{
  "id": 381,
  "question": "Como você estruturaria CSS/SCSS em um projeto grande?",
  "options": [
    { "id": 1, "name": "Metodologias como BEM, ITCSS ou CSS Modules com arquitetura por componentes", "alias": "a" },
    { "id": 2, "name": "Um único arquivo CSS global", "alias": "b" },
    { "id": 3, "name": "Estilos inline em todos os elementos", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Projetos grandes requerem arquitetura CSS organizada para evitar conflitos e facilitar manutenção.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: CSS architecture é crucial em projetos grandes para evitar specificity wars e side effects. ITCSS organiza por especificidade: Settings → Tools → Generic → Elements → Objects → Components → Utilities. BEM naming evita conflitos: .card__title--highlighted. CSS Modules ou styled-components fazem scoping automático. Estrutura: abstracts/ (variables, mixins), base/ (resets, typography), components/ (UI components), utilities/ (helper classes). Always mobile-first approach."
},
{
  "id": 382,
  "question": "O que é Web Assembly (WASM) e quando utilizá-lo?",
  "options": [
    { "id": 1, "name": "Formato binário que permite executar código de alta performance no browser", "alias": "a" },
    { "id": 2, "name": "Uma nova versão do JavaScript", "alias": "b" },
    { "id": 3, "name": "Um framework para desenvolvimento web", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "WebAssembly permite executar código compilado (C++, Rust, C#) no browser com performance próxima ao nativo.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: WebAssembly complementa JavaScript para computações heavy. Use cases: 1) Image/video processing, 2) Games com physics engines, 3) Cryptography operations, 4) Scientific computing, 5) Porting legacy C/C++ libraries. WASM executa em sandbox seguro, acessa DOM via JavaScript glue code. Linguagens: Rust, C/C++, C#, Go. Não substitui JS - é collaborative technology. Consider WASM quando JavaScript performance não é suficiente e computational cost justifica complexity overhead."
},
{
  "id": 383,
  "question": "Como você implementaria scroll infinito (infinite scroll) eficiente?",
  "options": [
    { "id": 1, "name": "Intersection Observer API com virtualization para grandes datasets", "alias": "a" },
    { "id": 2, "name": "Event listener no scroll carregando todos os dados", "alias": "b" },
    { "id": 3, "name": "setTimeout para carregar dados a cada segundo", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Infinite scroll eficiente usa Intersection Observer e virtualization para performance com grandes volumes de dados.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Infinite scroll eficiente evita scroll event listeners que degradam performance. Uso Intersection Observer para detectar quando user aproxima do final da lista. Para datasets grandes, implemento virtualization (só renderizo itens visíveis + buffer). Considerações UX: 1) Loading states claros, 2) Error handling com retry, 3) Preserve scroll position ao voltar, 4) Accessibility com proper ARIA announcements. Libraries como react-window ou ngx-virtual-scroller simplificam implementation."
},
{
  "id": 384,
  "question": "O que é Edge Computing e como impacta desenvolvimento frontend?",
  "options": [
    { "id": 1, "name": "Processamento próximo ao usuário que reduz latência e melhora performance", "alias": "a" },
    { "id": 2, "name": "Um novo framework JavaScript", "alias": "b" },
    { "id": 3, "name": "Uma técnica de CSS", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Edge Computing executa código próximo aos usuários, reduzindo latência através de CDNs distribuídas globalmente.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Edge Computing move computação para próximo dos users via CDN edge servers worldwide. Para frontend: 1) Edge-side rendering reduz TTFB, 2) A/B testing sem client-side overhead, 3) Personalization sem roundtrips, 4) Security filtering antes de chegar ao origin. Platforms como Cloudflare Workers, Vercel Edge Functions permitem rodar JavaScript no edge. Ideal for: geolocation-based content, authentication, caching logic, request routing. Consider cold start latency e limited runtime environment."
},
{
  "id": 385,
  "question": "Como você implementaria drag and drop acessível e responsivo?",
  "options": [
    { "id": 1, "name": "HTML5 Drag API com fallbacks para touch e teclado", "alias": "a" },
    { "id": 2, "name": "Apenas mouse events básicos", "alias": "b" },
    { "id": 3, "name": "Somente bibliotecas externas", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Drag and drop moderno requer suporte multi-input: mouse, touch e keyboard para acessibilidade completa.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Drag and drop inclusivo suporta todos input methods. HTML5 Drag API para mouse, touch events para mobile, keyboard navigation (Space/Enter para select, Arrow keys para move). ARIA live regions para screen reader feedback. Visual cues: drag handles, drop zones highlight, ghost images. Considerations: 1) Touch devices precision, 2) Auto-scroll during drag, 3) Undo/redo capability, 4) Data persistence. Libraries como react-beautiful-dnd ou SortableJS já solved these challenges com accessibility built-in."
},
{
  "id": 386,
  "question": "O que é a Shadow DOM e como ela melhora o encapsulamento?",
  "options": [
    { "id": 1, "name": "Parte do DOM isolada que encapsula estilos e markup de componentes", "alias": "a" },
    { "id": 2, "name": "Uma nova API para manipulação DOM", "alias": "b" },
    { "id": 3, "name": "Um framework JavaScript", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Shadow DOM cria um escopo isolado para componentes, prevenindo conflitos de estilo e comportamento.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: Shadow DOM isola component internals do global DOM. Cada web component tem seu próprio shadow root com styles e markup encapsulados. Benefícios: 1) No style leakage - estilos globais não afetam o componente e vice-versa, 2) Scoped CSS - use classes/id sem medo de conflitos, 3) Encapsulation of behavior - eventos e state são locais. Uso em Custom Elements nativos ou frameworks como Angular (ViewEncapsulation) e Stencil. Considerações: performance overhead, debugging challenges."
},
{
  "id": 387,
  "question": "Como você implementaria um sistema de permissões baseado em funções (RBAC) no frontend?",
  "options": [
    { "id": 1, "name": "Definindo roles e permissions, controlando acesso via guards e componentes protegidos", "alias": "a" },
    { "id": 2, "name": "Apenas escondendo botões no UI", "alias": "b" },
    { "id": 3, "name": "Armazenando permissões no localStorage", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "RBAC envolve definição clara de roles/permissions e controle de acesso tanto na UI quanto na lógica de navegação.",
  "category": "entrevista",
  "interviewTip": "Como explicar na entrevista: RBAC estrutura acesso baseado em roles (admin, user, guest) e permissions (read, write). Implemento: 1) Centralized role/permission definitions, 2) Route guards (Angular CanActivate, React PrivateRoute) para proteger rotas, 3) Conditional rendering de componentes/botões baseado em permissions, 4) Middleware para API calls que checa tokens/roles. Nunca confio apenas no frontend - backend deve validar permissions também. Uso JWT claims para transportar roles/permissions com segurança."
},
{
  "id": 388,
  "question": "Qual é o propósito da tag <main> no HTML5?",
  "options": [
    { "id": 1, "name": "Definir o conteúdo principal da página", "alias": "a" },
    { "id": 2, "name": "Criar um menu de navegação", "alias": "b" },
    { "id": 3, "name": "Adicionar estilos ao documento", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "A tag <main> define o conteúdo principal da página, excluindo header, footer e navegação.",
  "category": "html"
},
{
  "id": 389,
  "question": "O que é o atributo 'srcset' em uma tag <img>?",
  "options": [
    { "id": 1, "name": "Define múltiplas versões de uma imagem para diferentes resoluções", "alias": "a" },
    { "id": 2, "name": "Define a cor da imagem", "alias": "b" },
    { "id": 3, "name": "Define a largura da imagem", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "O atributo srcset permite especificar diferentes versões da imagem para diferentes densidades de pixels.",
  "category": "html"
},
{
  "id": 390,
  "question": "Qual é a função do atributo 'loading' em imagens HTML5?",
  "options": [
    { "id": 1, "name": "Controlar quando a imagem deve ser carregada", "alias": "a" },
    { "id": 2, "name": "Definir a velocidade de carregamento", "alias": "b" },
    { "id": 3, "name": "Determinar o formato da imagem", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "O atributo loading com valor 'lazy' permite carregamento tardio de imagens para melhorar performance.",
  "category": "html"
},
{
  "id": 391,
  "question": "O que é uma Progressive Web App (PWA)?",
  "options": [
    { "id": 1, "name": "Uma aplicação web que oferece experiência similar a aplicativos nativos", "alias": "a" },
    { "id": 2, "name": "Um tipo de banco de dados", "alias": "b" },
    { "id": 3, "name": "Uma linguagem de programação", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "PWAs combinam tecnologias web modernas para oferecer funcionalidades como trabalho offline e instalação.",
  "category": "html"
},
{
  "id": 392,
  "question": "Qual é o propósito da propriedade CSS 'display: grid'?",
  "options": [
    { "id": 1, "name": "Criar layouts bidimensionais com linhas e colunas", "alias": "a" },
    { "id": 2, "name": "Ocultar elementos da página", "alias": "b" },
    { "id": 3, "name": "Definir a cor de fundo", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "CSS Grid permite criar layouts complexos com controle preciso sobre linhas e colunas.",
  "category": "css"
},
{
  "id": 393,
  "question": "O que faz a propriedade CSS 'transform'?",
  "options": [
    { "id": 1, "name": "Aplica transformações 2D ou 3D aos elementos", "alias": "a" },
    { "id": 2, "name": "Muda a cor do texto", "alias": "b" },
    { "id": 3, "name": "Define o tamanho da fonte", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "A propriedade transform permite aplicar rotações, escalas, translações e inclinações aos elementos.",
  "category": "css"
},
{
  "id": 394,
  "question": "Qual é a função da propriedade CSS 'transition'?",
  "options": [
    { "id": 1, "name": "Criar animações suaves entre estados diferentes", "alias": "a" },
    { "id": 2, "name": "Definir a posição do elemento", "alias": "b" },
    { "id": 3, "name": "Alterar a cor do elemento", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "CSS transitions criam animações suaves quando propriedades CSS mudam de valor.",
  "category": "css"
},
{
  "id": 395,
  "question": "O que é CSS Custom Properties (CSS Variables)?",
  "options": [
    { "id": 1, "name": "Variáveis reutilizáveis que armazenam valores CSS", "alias": "a" },
    { "id": 2, "name": "Propriedades para definir cores", "alias": "b" },
    { "id": 3, "name": "Seletores especiais do CSS", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "CSS Custom Properties (--variavel) permitem reutilizar valores e criar temas dinâmicos.",
  "category": "css"
},
{
  "id": 396,
  "question": "Qual é o propósito do método 'reduce()' em JavaScript?",
  "options": [
    { "id": 1, "name": "Reduzir um array a um único valor através de uma função acumuladora", "alias": "a" },
    { "id": 2, "name": "Remover elementos duplicados de um array", "alias": "b" },
    { "id": 3, "name": "Ordenar elementos de um array", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "O método reduce aplica uma função a cada elemento do array, acumulando o resultado em um valor único.",
  "category": "javascript"
},
{
  "id": 397,
  "question": "O que é event delegation em JavaScript?",
  "options": [
    { "id": 1, "name": "Técnica de usar um elemento pai para gerenciar eventos de elementos filhos", "alias": "a" },
    { "id": 2, "name": "Método para criar novos eventos", "alias": "b" },
    { "id": 3, "name": "Forma de prevenir eventos padrão", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Event delegation aproveita o bubbling para gerenciar eventos de múltiplos elementos através de um ancestral comum.",
  "category": "javascript"
},
{
  "id": 398,
  "question": "O que é o método 'Object.assign()' em JavaScript?",
  "options": [
    { "id": 1, "name": "Copia propriedades de objetos fonte para um objeto destino", "alias": "a" },
    { "id": 2, "name": "Remove propriedades de um objeto", "alias": "b" },
    { "id": 3, "name": "Converte objeto em string", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Object.assign() copia propriedades enumeráveis de um ou mais objetos fonte para um objeto destino.",
  "category": "javascript"
},
{
  "id": 399,
  "question": "O que é destructuring assignment em JavaScript?",
  "options": [
    { "id": 1, "name": "Sintaxe para extrair valores de arrays ou propriedades de objetos", "alias": "a" },
    { "id": 2, "name": "Método para destruir variáveis", "alias": "b" },
    { "id": 3, "name": "Técnica para criar novos objetos", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Destructuring permite extrair dados de arrays ou objetos de forma concisa: const {name, age} = person.",
  "category": "javascript"
},
{
  "id": 400,
  "question": "Qual comando Git é usado para ver o histórico de commits?",
  "options": [
    { "id": 1, "name": "git log", "alias": "a" },
    { "id": 2, "name": "git history", "alias": "b" },
    { "id": 3, "name": "git show", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "O comando 'git log' exibe o histórico de commits do repositório atual.",
  "category": "versionamento"
},
{
  "id": 401,
  "question": "O que faz o comando 'git cherry-pick'?",
  "options": [
    { "id": 1, "name": "Aplica mudanças de commits específicos de outro branch", "alias": "a" },
    { "id": 2, "name": "Remove commits do histórico", "alias": "b" },
    { "id": 3, "name": "Cria um novo branch", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Cherry-pick permite aplicar mudanças de commits específicos sem fazer merge completo do branch.",
  "category": "versionamento"
},
{
  "id": 402,
  "question": "O que significa 'HEAD' no Git?",
  "options": [
    { "id": 1, "name": "Ponteiro para o commit atual onde você está trabalhando", "alias": "a" },
    { "id": 2, "name": "O primeiro commit do repositório", "alias": "b" },
    { "id": 3, "name": "O branch principal do projeto", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "HEAD é um ponteiro móvel que indica qual commit está atualmente verificado no workspace.",
  "category": "versionamento"
},
{
  "id": 403,
  "question": "Qual comando é usado para desfazer o último commit mantendo as alterações?",
  "options": [
    { "id": 1, "name": "git reset --soft HEAD~1", "alias": "a" },
    { "id": 2, "name": "git delete HEAD", "alias": "b" },
    { "id": 3, "name": "git undo commit", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "git reset --soft HEAD~1 desfaz o último commit mas mantém as alterações staged.",
  "category": "versionamento"
},
{
  "id": 404,
  "question": "O que é Container Queries no CSS?",
  "options": [
    { "id": 1, "name": "Media queries baseadas no tamanho do container pai em vez da viewport", "alias": "a" },
    { "id": 2, "name": "Consultas para bancos de dados", "alias": "b" },
    { "id": 3, "name": "Seletores CSS avançados", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Container Queries permitem aplicar estilos baseados no tamanho do container, não da tela.",
  "category": "responsividade"
},
{
  "id": 405,
  "question": "O que é a técnica de 'Mobile First' em CSS?",
  "options": [
    { "id": 1, "name": "Escrever CSS para dispositivos móveis primeiro, depois expandir para telas maiores", "alias": "a" },
    { "id": 2, "name": "Criar apenas versões mobile do site", "alias": "b" },
    { "id": 3, "name": "Otimizar apenas imagens para mobile", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Mobile First utiliza min-width media queries, começando pelo design móvel e expandindo para desktop.",
  "category": "responsividade"
},
{
  "id": 406,
  "question": "O que são Progressive Web Apps (PWA) em relação à responsividade?",
  "options": [
    { "id": 1, "name": "Apps que se adaptam automaticamente a qualquer dispositivo e funcionam offline", "alias": "a" },
    { "id": 2, "name": "Apps que funcionam apenas em desktop", "alias": "b" },
    { "id": 3, "name": "Apps que requerem instalação obrigatória", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "PWAs são responsivas por natureza e oferecem experiência consistente em todos os dispositivos.",
  "category": "responsividade"
},
{
  "id": 407,
  "question": "O que é o princípio 'Content First' no design responsivo?",
  "options": [
    { "id": 1, "name": "Priorizar o conteúdo na definição de breakpoints e layout", "alias": "a" },
    { "id": 2, "name": "Sempre colocar muito conteúdo na página", "alias": "b" },
    { "id": 3, "name": "Usar apenas texto sem imagens", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Content First significa que os breakpoints devem ser definidos baseados no conteúdo, não em dispositivos específicos.",
  "category": "responsividade"
},
{
  "id": 408,
  "question": "O que é um User Story no Scrum?",
  "options": [
    { "id": 1, "name": "Uma descrição simples de uma funcionalidade do ponto de vista do usuário", "alias": "a" },
    { "id": 2, "name": "A biografia do usuário final", "alias": "b" },
    { "id": 3, "name": "Um relatório de bugs encontrados", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "User Stories descrevem funcionalidades usando o formato: 'Como [usuário], eu quero [funcionalidade] para que [benefício]'.",
  "category": "scrum"
},
{
  "id": 409,
  "question": "O que são Story Points no Scrum?",
  "options": [
    { "id": 1, "name": "Unidade de medida para estimar o esforço relativo de User Stories", "alias": "a" },
    { "id": 2, "name": "Pontos ganhos ao completar tarefas", "alias": "b" },
    { "id": 3, "name": "Número de histórias no backlog", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Story Points estimam complexidade, esforço e incerteza usando escala relativa (Fibonacci é comum).",
  "category": "scrum"
},
{
  "id": 410,
  "question": "O que é Velocity no Scrum?",
  "options": [
    { "id": 1, "name": "Quantidade de trabalho que o time consegue completar em uma Sprint", "alias": "a" },
    { "id": 2, "name": "Velocidade da internet da equipe", "alias": "b" },
    { "id": 3, "name": "Tempo gasto em reuniões", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Velocity é medida em Story Points e ajuda a prever capacidade para próximas Sprints.",
  "category": "scrum"
},
{
  "id": 411,
  "question": "O que é um Spike no Scrum?",
  "options": [
    { "id": 1, "name": "Uma atividade de pesquisa ou investigação para reduzir incertezas", "alias": "a" },
    { "id": 2, "name": "Um bug crítico que precisa ser corrigido", "alias": "b" },
    { "id": 3, "name": "Uma reunião de emergência", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Spikes são timeboxed para investigar tecnologias, arquiteturas ou soluções antes da implementação.",
  "category": "scrum"
},
{
  "id": 412,
  "question": "O que é Infrastructure as Code (IaC) no DevOps?",
  "options": [
    { "id": 1, "name": "Gerenciar infraestrutura através de arquivos de configuração versionados", "alias": "a" },
    { "id": 2, "name": "Escrever código apenas para servidores", "alias": "b" },
    { "id": 3, "name": "Usar código para substituir hardware", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "IaC permite provisionar e gerenciar infraestrutura usando código, tornando o processo reproduzível e versionado.",
  "category": "devops"
},
{
  "id": 413,
  "question": "O que é um Container no contexto DevOps?",
  "options": [
    { "id": 1, "name": "Pacote que inclui aplicação e suas dependências isoladamente", "alias": "a" },
    { "id": 2, "name": "Pasta para armazenar arquivos", "alias": "b" },
    { "id": 3, "name": "Tipo de banco de dados", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Containers fornecem ambiente consistente e isolado para aplicações, facilitando deploy e escalabilidade.",
  "category": "devops"
},
{
  "id": 414,
  "question": "O que é Kubernetes no ecossistema DevOps?",
  "options": [
    { "id": 1, "name": "Plataforma de orquestração de containers", "alias": "a" },
    { "id": 2, "name": "Linguagem de programação", "alias": "b" },
    { "id": 3, "name": "Banco de dados distribuído", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Kubernetes automatiza deploy, escalonamento e gerenciamento de aplicações em containers.",
  "category": "devops"
},
{
  "id": 415,
  "question": "O que é Blue-Green Deployment?",
  "options": [
    { "id": 1, "name": "Estratégia de deploy que mantém dois ambientes idênticos para troca rápida", "alias": "a" },
    { "id": 2, "name": "Tipo de teste de interface", "alias": "b" },
    { "id": 3, "name": "Método de backup de dados", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Blue-Green permite rollback instantâneo alternando tráfego entre dois ambientes de produção.",
  "category": "devops"
},
{
  "id": 416,
  "question": "O que é uma assinatura digital em criptografia?",
  "options": [
    { "id": 1, "name": "Mecanismo que garante autenticidade e integridade de mensagens", "alias": "a" },
    { "id": 2, "name": "Arquivo de imagem digitalizada", "alias": "b" },
    { "id": 3, "name": "Senha de acesso a sistemas", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Assinaturas digitais usam criptografia de chave pública para verificar a origem e integridade dos dados.",
  "category": "criptografia"
},
{
  "id": 417,
  "question": "O que é uma VPN (Virtual Private Network)?",
  "options": [
    { "id": 1, "name": "Rede privada virtual que criptografa conexões através da internet", "alias": "a" },
    { "id": 2, "name": "Tipo de servidor web", "alias": "b" },
    { "id": 3, "name": "Protocolo de email seguro", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "VPNs criam túneis criptografados para proteger dados em redes públicas e mascarar localização.",
  "category": "criptografia"
},
{
  "id": 418,
  "question": "O que é PKI (Public Key Infrastructure)?",
  "options": [
    { "id": 1, "name": "Infraestrutura para gerenciar certificados e chaves públicas", "alias": "a" },
    { "id": 2, "name": "Protocolo de internet", "alias": "b" },
    { "id": 3, "name": "Tipo de firewall", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "PKI gerencia criação, distribuição e revogação de certificados digitais em sistemas criptográficos.",
  "category": "criptografia"
},
{
  "id": 419,
  "question": "O que é Two-Factor Authentication (2FA)?",
  "options": [
    { "id": 1, "name": "Método de autenticação que requer dois fatores diferentes para acesso", "alias": "a" },
    { "id": 2, "name": "Sistema de backup duplo", "alias": "b" },
    { "id": 3, "name": "Protocolo de rede", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "2FA combina algo que você sabe (senha) com algo que você tem (token/SMS) para maior segurança.",
  "category": "criptografia"
}, {
  "id": 420,
  "question": "O que é Responsive Typography e como implementá-la?",
  "options": [
    { "id": 1, "name": "Técnica que ajusta tamanhos de fonte baseado no tamanho da tela usando unidades como vw, rem ou clamp", "alias": "a" },
    { "id": 2, "name": "Usar sempre pixels para definir fontes", "alias": "b" },
    { "id": 3, "name": "Manter o mesmo tamanho de fonte em todos os dispositivos", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Responsive Typography usa unidades flexíveis e funções CSS para adaptar textos a diferentes telas.",
  "category": "responsividade"
},
{
  "id": 421,
  "question": "O que são Critical CSS e como melhoram a responsividade?",
  "options": [
    { "id": 1, "name": "CSS essencial para renderizar a parte visível da página rapidamente", "alias": "a" },
    { "id": 2, "name": "CSS que causa erros críticos", "alias": "b" },
    { "id": 3, "name": "CSS usado apenas para debugging", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Critical CSS extrai e inline os estilos necessários para renderizar o conteúdo above-the-fold.",
  "category": "responsividade"
},
{
  "id": 422,
  "question": "Como implementar imagens responsivas com multiple formats (WebP, AVIF)?",
  "options": [
    { "id": 1, "name": "Usando elemento <picture> com <source> para diferentes formatos", "alias": "a" },
    { "id": 2, "name": "Apenas convertendo todas as imagens para JPG", "alias": "b" },
    { "id": 3, "name": "Usando apenas CSS background-image", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "O elemento picture permite definir múltiplos formatos com fallbacks automáticos.",
  "category": "responsividade"
},
{
  "id": 423,
  "question": "O que é Responsive Web Design (RWD) versus Adaptive Web Design (AWD)?",
  "options": [
    { "id": 1, "name": "RWD usa layouts fluidos, AWD usa layouts fixos com breakpoints específicos", "alias": "a" },
    { "id": 2, "name": "São exatamente a mesma coisa", "alias": "b" },
    { "id": 3, "name": "AWD é usado apenas para mobile", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "RWD flui continuamente, enquanto AWD detecta o dispositivo e serve layout específico.",
  "category": "responsividade"
},
{
  "id": 424,
  "question": "Como otimizar performance em dispositivos móveis?",
  "options": [
    { "id": 1, "name": "Reduzindo bundle size, lazy loading, otimizando imagens e minimizando reflows", "alias": "a" },
    { "id": 2, "name": "Adicionando mais animações CSS", "alias": "b" },
    { "id": 3, "name": "Usando apenas JavaScript para todos os layouts", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Mobile performance requer otimizações específicas devido a hardware limitado.",
  "category": "responsividade"
},
{
  "id": 425,
  "question": "O que são Progressive Enhancement e Graceful Degradation?",
  "options": [
    { "id": 1, "name": "Progressive Enhancement constrói de base simples para cima, Graceful Degradation remove features avançadas", "alias": "a" },
    { "id": 2, "name": "São técnicas apenas para design visual", "alias": "b" },
    { "id": 3, "name": "São métodos de compressão de imagens", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Progressive Enhancement garante funcionalidade básica para todos, com melhorias incrementais.",
  "category": "responsividade"
},
{
  "id": 426,
  "question": "Como testar efetivamente a responsividade de uma aplicação?",
  "options": [
    { "id": 1, "name": "Usando DevTools, dispositivos reais, ferramentas como BrowserStack e testes automatizados", "alias": "a" },
    { "id": 2, "name": "Apenas testando no desktop", "alias": "b" },
    { "id": 3, "name": "Confiando apenas no design mockup", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Teste de responsividade requer múltiplas ferramentas e dispositivos para cobertura completa.",
  "category": "responsividade"
},
{
  "id": 427,
  "question": "O que são Angular Signals e quando usá-los?",
  "options": [
    { "id": 1, "name": "Sistema reativo para gerenciar estado e mudanças de forma mais eficiente", "alias": "a" },
    { "id": 2, "name": "Eventos emitidos automaticamente pelo Angular", "alias": "b" },
    { "id": 3, "name": "Sinais de erro do compilador", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Angular Signals oferecem uma abordagem mais simples e performática para reatividade.",
  "category": "angular"
},
{
  "id": 428,
  "question": "O que é Angular Universal?",
  "options": [
    { "id": 1, "name": "Tecnologia para renderização server-side de aplicações Angular", "alias": "a" },
    { "id": 2, "name": "Um novo framework Angular", "alias": "b" },
    { "id": 3, "name": "Uma biblioteca de componentes UI", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Angular Universal permite renderizar aplicações Angular no servidor, melhorando SEO e performance.",
  "category": "angular"
},
{
  "id": 429,
  "question": "O que é o atributo 'role' em HTML e sua importância para acessibilidade?",
  "options": [
    { "id": 1, "name": "Define o papel semântico de um elemento para tecnologias assistivas", "alias": "a" },
    { "id": 2, "name": "Define a posição do elemento na página", "alias": "b" },
    { "id": 3, "name": "Define o estilo visual do elemento", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "O atributo role comunica a função de um elemento para leitores de tela e outras tecnologias assistivas.",
  "category": "html"
},
{
  "id": 430,
  "question": "Qual é a diferença entre as tags <b> e <strong> no HTML?",
  "options": [
    { "id": 1, "name": "<strong> tem significado semântico de importância, <b> é apenas visual", "alias": "a" },
    { "id": 2, "name": "Ambas têm exatamente a mesma função", "alias": "b" },
    { "id": 3, "name": "<b> é mais importante semanticamente que <strong>", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "<strong> indica importância semântica, enquanto <b> é apenas formatação visual sem significado.",
  "category": "html"
},
{
  "id": 431,
  "question": "O que é o atributo 'data-*' no HTML5 e como usá-lo?",
  "options": [
    { "id": 1, "name": "Permite armazenar dados customizados privados na página ou aplicação", "alias": "a" },
    { "id": 2, "name": "Define o tipo de dados do elemento", "alias": "b" },
    { "id": 3, "name": "Especifica a fonte dos dados do elemento", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Atributos data-* permitem armazenar informações customizadas que podem ser acessadas via JavaScript.",
  "category": "html"
},
{
  "id": 432,
  "question": "O que é o atributo 'aria-live' e como ele melhora a acessibilidade?",
  "options": [
    { "id": 1, "name": "Indica que uma região da página pode ser atualizada dinamicamente e deve ser anunciada por leitores de tela", "alias": "a" },
    { "id": 2, "name": "Define a cor do texto para leitores de tela", "alias": "b" },
    { "id": 3, "name": "Especifica o idioma do conteúdo", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "O atributo aria-live informa leitores de tela sobre mudanças dinâmicas em áreas específicas da página.",
  "category": "html"
},
{
  "id": 433,
  "question": "O que é o CSS-in-JS e quais suas vantagens?",
  "options": [
    { "id": 1, "name": "Técnica de escrever estilos CSS dentro do JavaScript com escopo automático", "alias": "a" },
    { "id": 2, "name": "Uma biblioteca para animações CSS", "alias": "b" },
    { "id": 3, "name": "Um preprocessador como SASS", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "CSS-in-JS permite escrever estilos com JavaScript, oferecendo escopo automático e tipagem.",
  "category": "css"
},
{
  "id": 434,
  "question": "Qual é a função da propriedade CSS 'contain'?",
  "options": [
    { "id": 1, "name": "Otimiza renderização isolando mudanças de layout, estilo e pintura", "alias": "a" },
    { "id": 2, "name": "Define o conteúdo de um elemento", "alias": "b" },
    { "id": 3, "name": "Controla a visibilidade do elemento", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "A propriedade contain informa ao navegador que mudanças no elemento não afetam outros elementos.",
  "category": "css"
},
{
  "id": 435,
  "question": "O que são CSS Logical Properties?",
  "options": [
    { "id": 1, "name": "Propriedades que se adaptam à direção de escrita (LTR/RTL)", "alias": "a" },
    { "id": 2, "name": "Propriedades que usam operadores lógicos", "alias": "b" },
    { "id": 3, "name": "Propriedades exclusivas para JavaScript", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Logical Properties como margin-inline-start se adaptam automaticamente à direção do texto.",
  "category": "css"
},
{
  "id": 436,
  "question": "O que é CSS Subgrid?",
  "options": [
    { "id": 1, "name": "Permite que um grid item tenha seus próprios itens filhos participem do grid pai", "alias": "a" },
    { "id": 2, "name": "Uma versão menor do CSS Grid", "alias": "b" },
    { "id": 3, "name": "Um framework CSS para grids", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Subgrid permite que elementos filhos de um grid item participem do layout grid principal.",
  "category": "css"
},
{
  "id": 437,
  "question": "Qual é a função da propriedade 'aspect-ratio' em CSS?",
  "options": [
    { "id": 1, "name": "Define a proporção largura/altura de um elemento", "alias": "a" },
    { "id": 2, "name": "Define o tamanho da fonte", "alias": "b" },
    { "id": 3, "name": "Controla a opacidade", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "aspect-ratio: 16/9 mantém a proporção do elemento independente de seu tamanho.",
  "category": "css"
},
{
  "id": 438,
  "question": "O que é CSS Cascade Layers (@layer)?",
  "options": [
    { "id": 1, "name": "Sistema para organizar e controlar a precedência de estilos CSS", "alias": "a" },
    { "id": 2, "name": "Técnica para criar animações em camadas", "alias": "b" },
    { "id": 3, "name": "Método para agrupar seletores", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Cascade Layers permitem controlar explicitamente a ordem de precedência dos estilos.",
  "category": "css"
},
{
  "id": 439,
  "question": "Para que serve a função CSS 'clamp()'?",
  "options": [
    { "id": 1, "name": "Define um valor que varia entre um mínimo e máximo baseado em uma condição", "alias": "a" },
    { "id": 2, "name": "Fixa um elemento na tela", "alias": "b" },
    { "id": 3, "name": "Cria animações suaves", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "clamp(min, preferred, max) é ideal para tipografia responsiva: clamp(1rem, 4vw, 2rem).",
  "category": "css"
},
{
  "id": 440,
  "question": "O que é CSS Houdini?",
  "options": [
    { "id": 1, "name": "Conjunto de APIs que permite estender o CSS com JavaScript", "alias": "a" },
    { "id": 2, "name": "Um novo framework CSS", "alias": "b" },
    { "id": 3, "name": "Uma ferramenta de debugging", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "CSS Houdini permite criar custom properties, layout algorithms e paint functions.",
  "category": "css"
},
{
  "id": 441,
  "question": "Qual é a função da propriedade 'scroll-behavior'?",
  "options": [
    { "id": 1, "name": "Controla o comportamento de rolagem (smooth ou auto)", "alias": "a" },
    { "id": 2, "name": "Define a direção da rolagem", "alias": "b" },
    { "id": 3, "name": "Oculta a barra de rolagem", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "scroll-behavior: smooth cria animação suave ao rolar para âncoras ou usar scrollIntoView().",
  "category": "css"
},
{
  "id": 442,
  "question": "O que são CSS Scroll Snap properties?",
  "options": [
    { "id": 1, "name": "Propriedades que fazem elementos 'grudarem' em posições específicas durante rolagem", "alias": "a" },
    { "id": 2, "name": "Propriedades para capturar screenshots", "alias": "b" },
    { "id": 3, "name": "Propriedades para acelerar rolagem", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Scroll snap cria experiências de rolagem similar a carrosséis nativos em mobile.",
  "category": "css"
},
{
  "id": 443,
  "question": "Para que serve a propriedade 'overscroll-behavior'?",
  "options": [
    { "id": 1, "name": "Controla o que acontece quando o usuário rola além do limite do elemento", "alias": "a" },
    { "id": 2, "name": "Define a velocidade de rolagem", "alias": "b" },
    { "id": 3, "name": "Oculta conteúdo que transborda", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "overscroll-behavior: contain evita que rolagem de modais afete a página principal.",
  "category": "css"
},
{
  "id": 444,
  "question": "O que é CSS Paint API?",
  "options": [
    { "id": 1, "name": "API que permite criar imagens CSS personalizadas usando JavaScript", "alias": "a" },
    { "id": 2, "name": "API para colorir elementos automaticamente", "alias": "b" },
    { "id": 3, "name": "Ferramenta para escolher cores", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Paint API permite criar backgrounds, borders e máscaras customizadas programaticamente.",
  "category": "css"
},
{
  "id": 445,
  "question": "Qual é a diferença entre 'gap' e 'margin' em CSS Grid/Flexbox?",
  "options": [
    { "id": 1, "name": "gap cria espaço apenas entre itens, margin adiciona espaço ao redor de cada item", "alias": "a" },
    { "id": 2, "name": "gap e margin fazem exatamente a mesma coisa", "alias": "b" },
    { "id": 3, "name": "gap só funciona em Grid, não em Flexbox", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "gap é mais eficiente para espaçamento interno em containers flex/grid que margin.",
  "category": "css"
},
{
  "id": 446,
  "question": "O que é o CSS Feature Queries (@supports)?",
  "options": [
    { "id": 1, "name": "Permite aplicar estilos condicionalmente baseado no suporte do navegador a uma propriedade", "alias": "a" },
    { "id": 2, "name": "Define estilos para dispositivos específicos", "alias": "b" },
    { "id": 3, "name": "Verifica a versão do CSS suportada", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "@supports permite escrever CSS que só será aplicado se o navegador suportar a feature especificada.",
  "category": "css"
},
{
  "id": 447,
  "question": "O que é o CSS Object Fit e quando usá-lo?",
  "options": [
    { "id": 1, "name": "Propriedade que define como o conteúdo de um elemento (como imagens) deve se ajustar ao seu contêiner", "alias": "a" },
    { "id": 2, "name": "Propriedade para ajustar o tamanho da fonte", "alias": "b" },
    { "id": 3, "name": "Propriedade para alinhar texto", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "object-fit: cover; faz a imagem preencher o contêiner sem distorcer, cortando se necessário.",
  "category": "css"
},
{
  "id": 448,
  "question": "O que é o método 'Array.from()' em JavaScript?",
  "options": [
    { "id": 1, "name": "Converte objetos iteráveis ou array-like em arrays reais", "alias": "a" },
    { "id": 2, "name": "Remove elementos de um array", "alias": "b" },
    { "id": 3, "name": "Ordena elementos de um array", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Array.from() cria uma nova instância de Array a partir de objetos iteráveis ou array-like.",
  "category": "javascript"
},
{
  "id": 449,
  "question": "Qual é a diferença entre 'null' e 'undefined' em JavaScript?",
  "options": [
    { "id": 1, "name": "'null' é um valor atribuído intencionalmente, 'undefined' indica ausência de valor", "alias": "a" },
    { "id": 2, "name": "São exatamente iguais", "alias": "b" },
    { "id": 3, "name": "'undefined' é usado apenas em objetos", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "null é uma atribuição intencional de 'nenhum valor', undefined indica que a variável foi declarada mas não recebeu valor.",
  "category": "javascript"
},
{
  "id": 450,
  "question": "O que é o spread operator (...) em JavaScript?",
  "options": [
    { "id": 1, "name": "Operador que expande elementos de arrays, objetos ou strings", "alias": "a" },
    { "id": 2, "name": "Operador para criar loops", "alias": "b" },
    { "id": 3, "name": "Operador para comparar valores", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "O spread operator (...) permite expandir elementos iteráveis em lugares onde múltiplos elementos são esperados.",
  "category": "javascript"
},
{
  "id": 451,
  "question": "O que é o método 'Array.prototype.find()' em JavaScript?",
  "options": [
    { "id": 1, "name": "Retorna o primeiro elemento que satisfaz a condição fornecida", "alias": "a" },
    { "id": 2, "name": "Encontra todos os elementos de um array", "alias": "b" },
    { "id": 3, "name": "Remove elementos de um array", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "find() retorna o primeiro elemento do array que satisfaz a função de teste fornecida, ou undefined se não encontrar.",
  "category": "javascript"
},
{
  "id": 452,
  "question": "O que é o conceito de 'modules' em JavaScript moderno?",
  "options": [
    { "id": 1, "name": "Sistema para organizar código em arquivos separados com import/export", "alias": "a" },
    { "id": 2, "name": "Função para criar variáveis globais", "alias": "b" },
    { "id": 3, "name": "Método para criar objetos", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Modules (ES6) permitem dividir código em arquivos separados, exportando e importando funcionalidades conforme necessário.",
  "category": "javascript"
},
{
  "id": 453,
  "question": "Qual é o principal desafio ao compartilhar dependências entre microfrontends?",
  "options": [
    { "id": 1, "name": "Gerenciar versões conflitantes e tamanho do bundle", "alias": "a" },
    { "id": 2, "name": "Criar novos componentes", "alias": "b" },
    { "id": 3, "name": "Definir rotas da aplicação", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Diferentes microfrontends podem usar versões diferentes da mesma dependência, causando conflitos e aumento do bundle.",
  "category": "micro-front-end"
},
{
  "id": 454,
  "question": "O que é Module Federation no contexto de microfrontends?",
  "options": [
    { "id": 1, "name": "Tecnologia que permite compartilhar código entre aplicações JavaScript de forma dinâmica", "alias": "a" },
    { "id": 2, "name": "Um framework para criar interfaces", "alias": "b" },
    { "id": 3, "name": "Uma biblioteca de componentes", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Module Federation permite que aplicações carreguem dinamicamente código de outras aplicações em runtime.",
  "category": "micro-front-end"
},
{
  "id": 455,
  "question": "Como implementar roteamento em uma arquitetura de microfrontends?",
  "options": [
    { "id": 1, "name": "Usando um shell application que gerencia rotas e carrega microfrontends", "alias": "a" },
    { "id": 2, "name": "Cada microfrontend gerencia suas próprias rotas independentemente", "alias": "b" },
    { "id": 3, "name": "Não é possível usar roteamento em microfrontends", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Um container/shell application coordena as rotas e decide qual microfrontend carregar para cada rota.",
  "category": "micro-front-end"
},
{
  "id": 456,
  "question": "Qual estratégia é recomendada para deploy de microfrontends?",
  "options": [
    { "id": 1, "name": "Deploy independente de cada microfrontend com versionamento", "alias": "a" },
    { "id": 2, "name": "Deploy de todos os microfrontends simultaneamente", "alias": "b" },
    { "id": 3, "name": "Deploy manual apenas quando necessário", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Cada microfrontend deve poder ser deployado independentemente, permitindo agilidade e autonomia dos times.",
  "category": "micro-front-end"
},
{
  "id": 457,
  "question": "Como lidar com SEO em aplicações microfrontend?",
  "options": [
    { "id": 1, "name": "Implementar Server-Side Rendering no shell application e meta tags dinâmicas", "alias": "a" },
    { "id": 2, "name": "SEO não é possível com microfrontends", "alias": "b" },
    { "id": 3, "name": "Apenas usar meta tags estáticas", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "O shell application deve coordenar SSR e meta tags dinâmicas baseadas no microfrontend ativo.",
  "category": "micro-front-end"
},
{
  "id": 458,
  "question": "O que é Test-Driven Development (TDD) e quais seus benefícios?",
  "options": [
    { "id": 1, "name": "Metodologia onde escreve-se o teste antes do código, garantindo melhor design", "alias": "a" },
    { "id": 2, "name": "Escrever testes apenas após terminar toda a funcionalidade", "alias": "b" },
    { "id": 3, "name": "Testar apenas as funções mais importantes", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "TDD segue o ciclo Red-Green-Refactor, melhorando design de código e cobertura de testes.",
  "category": "testes-unitarios"
},
{
  "id": 459,
  "question": "Como testar funções assíncronas em JavaScript?",
  "options": [
    { "id": 1, "name": "Usando async/await nos testes e esperando promises resolverem", "alias": "a" },
    { "id": 2, "name": "Não é possível testar código assíncrono", "alias": "b" },
    { "id": 3, "name": "Apenas com setTimeout", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Testes assíncronos devem aguardar promises com async/await ou usar callbacks done() conforme o framework.",
  "category": "testes-unitarios"
},
{
  "id": 460,
  "question": "O que é Behavior-Driven Development (BDD)?",
  "options": [
    { "id": 1, "name": "Abordagem que foca em descrever o comportamento esperado usando linguagem natural", "alias": "a" },
    { "id": 2, "name": "Tipo de teste apenas para APIs", "alias": "b" },
    { "id": 3, "name": "Framework específico para testes", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "BDD usa sintaxe Given-When-Then para descrever cenários de teste em linguagem compreensível para todos.",
  "category": "testes-unitarios"
},
{
  "id": 461,
  "question": "Como testar componentes que dependem do DOM?",
  "options": [
    { "id": 1, "name": "Usando ferramentas como Testing Library ou Enzyme para renderizar componentes", "alias": "a" },
    { "id": 2, "name": "Não é possível testar componentes DOM", "alias": "b" },
    { "id": 3, "name": "Apenas testando a lógica sem renderização", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Testing Library e similares fornecem utilities para renderizar e interagir com componentes em ambiente de teste.",
  "category": "testes-unitarios"
},
{
  "id": 462,
  "question": "Qual é a importância dos testes de snapshot?",
  "options": [
    { "id": 1, "name": "Detectam mudanças não intencionais na saída/renderização de componentes", "alias": "a" },
    { "id": 2, "name": "Testam a performance da aplicação", "alias": "b" },
    { "id": 3, "name": "Verificam a segurança do código", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Snapshot tests capturam a saída de componentes e alertam quando há mudanças, ajudando a detectar regressões visuais.",
  "category": "testes-unitarios"
},
{
  "id": 463,
  "question": "O que é o Virtual DOM e como ele melhora a performance?",
  "options": [
    { "id": 1, "name": "Representação em memória do DOM real que permite otimizar atualizações", "alias": "a" },
    { "id": 2, "name": "Uma nova versão do DOM padrão", "alias": "b" },
    { "id": 3, "name": "Uma técnica para criar animações", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Virtual DOM permite calcular as mudanças necessárias antes de aplicar no DOM real, otimizando a performance.",
  "category": "front-end"
},
{
  "id": 464,
  "question": "O que são Service Workers e qual sua principal função?",
  "options": [
    { "id": 1, "name": "Scripts que executam em background para cache, push notifications e funcionalidade offline", "alias": "a" },
    { "id": 2, "name": "Trabalhadores que mantêm servidores web", "alias": "b" },
    { "id": 3, "name": "Componentes para criar interfaces de usuário", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Service Workers são scripts que rodam separadamente da página principal, permitindo funcionalidades como cache e trabalho offline.",
  "category": "front-end"
},
{
  "id": 465,
  "question": "O que é Cross-Origin Resource Sharing (CORS)?",
  "options": [
    { "id": 1, "name": "Mecanismo que permite requisições seguras entre diferentes domínios", "alias": "a" },
    { "id": 2, "name": "Protocolo para compartilhar arquivos", "alias": "b" },
    { "id": 3, "name": "Método de compressão de dados", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "CORS define como navegadores e servidores devem interagir ao fazer requisições cross-origin de forma segura.",
  "category": "front-end"
},
{
  "id": 466,
  "question": "O que é Bundle Splitting e por que é importante?",
  "options": [
    { "id": 1, "name": "Técnica de dividir o código em múltiplos arquivos para otimizar carregamento", "alias": "a" },
    { "id": 2, "name": "Método para organizar pastas do projeto", "alias": "b" },
    { "id": 3, "name": "Forma de separar HTML, CSS e JavaScript", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Bundle splitting permite carregar apenas o código necessário inicialmente, melhorando o tempo de carregamento.",
  "category": "front-end"
},
{
  "id": 467,
  "question": "O que é Tree Shaking no contexto de build tools?",
  "options": [
    { "id": 1, "name": "Técnica para remover código morto (não utilizado) do bundle final", "alias": "a" },
    { "id": 2, "name": "Processo de organizar arquivos em estrutura de árvore", "alias": "b" },
    { "id": 3, "name": "Método para criar animações de elementos", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Tree shaking analisa o código e remove partes não utilizadas, reduzindo o tamanho do bundle final.",
  "category": "front-end"
},
{
  "id": 468,
  "question": "O que é GitOps e como funciona?",
  "options": [
    { "id": 1, "name": "Metodologia que usa Git como fonte única da verdade para infraestrutura e deployments", "alias": "a" },
    { "id": 2, "name": "Ferramenta para gerenciar repositórios Git", "alias": "b" },
    { "id": 3, "name": "Sistema operacional baseado em Git", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "GitOps automatiza deployments usando Git como interface declarativa para gerenciar infraestrutura.",
  "category": "devops"
},
{
  "id": 469,
  "question": "O que é Helm no contexto Kubernetes?",
  "options": [
    { "id": 1, "name": "Gerenciador de pacotes para Kubernetes que facilita instalação de aplicações", "alias": "a" },
    { "id": 2, "name": "Interface gráfica para Kubernetes", "alias": "b" },
    { "id": 3, "name": "Tipo especial de container", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Helm usa charts (templates) para definir, instalar e atualizar aplicações Kubernetes complexas.",
  "category": "devops"
},
{
  "id": 470,
  "question": "O que é Canary Deployment?",
  "options": [
    { "id": 1, "name": "Estratégia de deploy que libera gradualmente para uma pequena porção de usuários", "alias": "a" },
    { "id": 2, "name": "Deploy que acontece apenas durante a madrugada", "alias": "b" },
    { "id": 3, "name": "Backup automático antes do deploy", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Canary deployment reduz riscos testando novas versões com um subconjunto de usuários antes do rollout completo.",
  "category": "devops"
},
{
  "id": 471,
  "question": "O que é Prometheus no ecossistema DevOps?",
  "options": [
    { "id": 1, "name": "Sistema de monitoramento e alertas com time-series database", "alias": "a" },
    { "id": 2, "name": "Ferramenta de versionamento de código", "alias": "b" },
    { "id": 3, "name": "Container runtime", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Prometheus coleta métricas de aplicações e infraestrutura, fornecendo alertas e dados para análise.",
  "category": "devops"
},
{
  "id": 472,
  "question": "O que é Service Mesh?",
  "options": [
    { "id": 1, "name": "Camada de infraestrutura que gerencia comunicação entre microserviços", "alias": "a" },
    { "id": 2, "name": "Rede física entre servidores", "alias": "b" },
    { "id": 3, "name": "Interface web para gerenciar serviços", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Service Mesh como Istio fornece descoberta de serviços, balanceamento de carga, criptografia e observabilidade.",
  "category": "devops"
},
{
  "id": 473,
  "question": "O que é Terraform?",
  "options": [
    { "id": 1, "name": "ferramenta de Infrastructure as Code para provisionar recursos em múltiplas clouds", "alias": "a" },
    { "id": 2, "name": "Sistema de containerização", "alias": "b" },
    { "id": 3, "name": "Linguagem de programação", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Terraform usa linguagem declarativa (HCL) para definir infraestrutura como código de forma reproduzível.",
  "category": "devops"
},
{
  "id": 474,
  "question": "O que é Ansible?",
  "options": [
    { "id": 1, "name": "Ferramenta de automação para configuração e gerenciamento de sistemas", "alias": "a" },
    { "id": 2, "name": "Banco de dados distribuído", "alias": "b" },
    { "id": 3, "name": "Framework para desenvolvimento web", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Ansible usa playbooks YAML para automatizar instalação, configuração e deployment de software.",
  "category": "devops"
},
{
  "id": 475,
  "question": "O que é um Reverse Proxy?",
  "options": [
    { "id": 1, "name": "Servidor intermediário que encaminha requests de clientes para servidores backend", "alias": "a" },
    { "id": 2, "name": "Backup dos dados do servidor", "alias": "b" },
    { "id": 3, "name": "Firewall para proteger aplicações", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Reverse proxy como Nginx distribui carga, fornece SSL termination e cache para aplicações.",
  "category": "devops"
},
{
  "id": 476,
  "question": "O que é Load Balancing?",
  "options": [
    { "id": 1, "name": "Distribuição de requisições entre múltiplos servidores para otimizar recursos", "alias": "a" },
    { "id": 2, "name": "Processo de backup de dados", "alias": "b" },
    { "id": 3, "name": "Otimização de código JavaScript", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Load balancers distribuem tráfego usando algoritmos como round-robin, least connections ou weighted.",
  "category": "devops"
},
{
  "id": 477,
  "question": "O que é Observability em DevOps?",
  "options": [
    { "id": 1, "name": "Capacidade de entender o estado interno de um sistema através de logs, métricas e traces", "alias": "a" },
    { "id": 2, "name": "Processo de revisar código manualmente", "alias": "b" },
    { "id": 3, "name": "Técnica para otimizar banco de dados", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Observability vai além do monitoramento, permitindo fazer perguntas sobre o comportamento do sistema.",
  "category": "devops"
},
{
  "id": 478,
  "question": "Qual é a diferença entre Continuous Integration e Continuous Deployment?",
  "options": [
    { "id": 1, "name": "CI integra código frequentemente, CD automatiza deploy para produção", "alias": "a" },
    { "id": 2, "name": "São exatamente a mesma coisa", "alias": "b" },
    { "id": 3, "name": "CI é para backend, CD é para frontend", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "CI foca na integração contínua de código, enquanto CD automatiza o deploy até produção.",
  "category": "ci-cd"
},
{
  "id": 479,
  "question": "O que são gates de qualidade (quality gates) em CI/CD?",
  "options": [
    { "id": 1, "name": "Critérios que devem ser atendidos antes do código prosseguir no pipeline", "alias": "a" },
    { "id": 2, "name": "Portões físicos nos servidores", "alias": "b" },
    { "id": 3, "name": "Ferramentas para testar interfaces", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Quality gates verificam cobertura de testes, code quality e outros critérios antes de permitir deploy.",
  "category": "ci-cd"
},
{
  "id": 480,
  "question": "O que é Blue-Green deployment em CI/CD?",
  "options": [
    { "id": 1, "name": "Estratégia que mantém dois ambientes idênticos para switch instantâneo", "alias": "a" },
    { "id": 2, "name": "Deploy usando apenas cores azul e verde no UI", "alias": "b" },
    { "id": 3, "name": "Tipo de teste automatizado", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Blue-Green permite deploy sem downtime alternando entre dois ambientes de produção.",
  "category": "ci-cd"
},
{
  "id": 481,
  "question": "Qual é o papel dos feature flags em CI/CD?",
  "options": [
    { "id": 1, "name": "Permitem ativar/desativar funcionalidades sem redeploy", "alias": "a" },
    { "id": 2, "name": "Marcam código como feature branch", "alias": "b" },
    { "id": 3, "name": "Definem configurações de build", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Feature flags facilitam deploy contínuo e rollback de features sem afetar o pipeline.",
  "category": "ci-cd"
},
{
  "id": 482,
  "question": "O que é rollback automático em pipelines CI/CD?",
  "options": [
    { "id": 1, "name": "Reversão automática para versão anterior quando deploy falha", "alias": "a" },
    { "id": 2, "name": "Backup automático do código", "alias": "b" },
    { "id": 3, "name": "Reset do banco de dados", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Rollback automático detecta falhas em produção e reverte para a versão estável anterior.",
  "category": "ci-cd"
},
{
  "id": 483,
  "question": "Qual é a importância do paralelismo em pipelines CI/CD?",
  "options": [
    { "id": 1, "name": "Executa múltiplas tarefas simultaneamente para reduzir tempo de build", "alias": "a" },
    { "id": 2, "name": "Executa testes apenas em produção", "alias": "b" },
    { "id": 3, "name": "Impede que múltiplos desenvolvedores façam commit", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Paralelização de testes, builds e checks reduz significativamente o tempo do pipeline.",
  "category": "ci-cd"
},
{
  "id": 484,
  "question": "O que são environment variables em CI/CD?",
  "options": [
    { "id": 1, "name": "Variáveis que armazenam configurações específicas de cada ambiente", "alias": "a" },
    { "id": 2, "name": "Variáveis que definem a cor do ambiente", "alias": "b" },
    { "id": 3, "name": "Variáveis para configurar o hardware", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Environment variables permitem diferentes configurações entre dev, staging e produção.",
  "category": "ci-cd"
},
{
  "id": 485,
  "question": "Qual é o conceito de 'fail fast' em CI/CD?",
  "options": [
    { "id": 1, "name": "Parar o pipeline imediatamente quando um erro é detectado", "alias": "a" },
    { "id": 2, "name": "Fazer deploy o mais rápido possível", "alias": "b" },
    { "id": 3, "name": "Falhar propositalmente para testar rollback", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Fail fast economiza tempo e recursos parando execução assim que um problema é detectado.",
  "category": "ci-cd"
},
{
  "id": 486,
  "question": "O que são smoke tests em CI/CD?",
  "options": [
    { "id": 1, "name": "Testes básicos que verificam se a aplicação está funcionando após deploy", "alias": "a" },
    { "id": 2, "name": "Testes de performance sob carga", "alias": "b" },
    { "id": 3, "name": "Testes que verificam a qualidade do ar", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Smoke tests fazem verificações rápidas das funcionalidades críticas após deploy.",
  "category": "ci-cd"
},
{
  "id": 487,
  "question": "Qual é a função do cache em pipelines CI/CD?",
  "options": [
    { "id": 1, "name": "Reutilizar dependências e artefatos para acelerar builds", "alias": "a" },
    { "id": 2, "name": "Armazenar logs de execução", "alias": "b" },
    { "id": 3, "name": "Fazer backup do código", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Cache evita re-download de dependências e recompilação desnecessária entre execuções.",
  "category": "ci-cd"
},
{
  "id": 488,
  "question": "O que é Canary deployment em CI/CD?",
  "options": [
    { "id": 1, "name": "Deploy gradual para pequena porcentagem de usuários antes do rollout completo", "alias": "a" },
    { "id": 2, "name": "Deploy usando pássaros como tema", "alias": "b" },
    { "id": 3, "name": "Deploy apenas durante o dia", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Canary deployment reduz riscos testando com subconjunto de usuários reais.",
  "category": "ci-cd"
},
{
  "id": 489,
  "question": "Qual é a importância da auditoria em pipelines CI/CD?",
  "options": [
    { "id": 1, "name": "Rastreabilidade de mudanças e conformidade com regulamentações", "alias": "a" },
    { "id": 2, "name": "Verificar apenas a qualidade do código", "alias": "b" },
    { "id": 3, "name": "Testar a performance da aplicação", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Auditoria mantém histórico completo de deployments para compliance e troubleshooting.",
  "category": "ci-cd"
},
{
  "id": 490,
  "question": "O que são deployment slots em CI/CD?",
  "options": [
    { "id": 1, "name": "Ambientes temporários para testar deploys antes de afetar produção", "alias": "a" },
    { "id": 2, "name": "Horários específicos para fazer deploy", "alias": "b" },
    { "id": 3, "name": "Slots de memória para aplicações", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Deployment slots permitem teste e aquecimento da nova versão antes do swap com produção.",
  "category": "ci-cd"
},
{
  "id": 491,
  "question": "Qual é o papel da observabilidade em CI/CD?",
  "options": [
    { "id": 1, "name": "Monitorar métricas e logs para detectar problemas em deployments", "alias": "a" },
    { "id": 2, "name": "Observar manualmente cada deploy", "alias": "b" },
    { "id": 3, "name": "Fazer screenshots das aplicações", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Observabilidade fornece insights para detectar e diagnosticar problemas rapidamente.",
  "category": "ci-cd"
},
{
  "id": 492,
  "question": "O que é GitFlow em relação ao CI/CD?",
  "options": [
    { "id": 1, "name": "Estratégia de branching que se integra com pipelines para diferentes tipos de release", "alias": "a" },
    { "id": 2, "name": "Ferramenta para controle de versão", "alias": "b" },
    { "id": 3, "name": "Protocolo de comunicação Git", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "GitFlow define como branches (feature, develop, release) devem triggerar diferentes pipelines.",
  "category": "ci-cd"
},
{
  "id": 493,
  "question": "Qual é a diferença entre code review síncrono e assíncrono?",
  "options": [
    { "id": 1, "name": "Síncrono em tempo real (pair programming), assíncrono por pull requests", "alias": "a" },
    { "id": 2, "name": "Síncrono para frontend, assíncrono para backend", "alias": "b" },
    { "id": 3, "name": "Não há diferença entre eles", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Code review síncrono acontece em tempo real, enquanto assíncrono através de ferramentas como PR/MR.",
  "category": "code-review"
},
{
  "id": 494,
  "question": "O que são code review guidelines e por que são importantes?",
  "options": [
    { "id": 1, "name": "Padrões definidos pela equipe para manter consistência na revisão", "alias": "a" },
    { "id": 2, "name": "Documentação técnica da aplicação", "alias": "b" },
    { "id": 3, "name": "Manuais de instalação de ferramentas", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Guidelines padronizam critérios de revisão e expectativas entre os membros da equipe.",
  "category": "code-review"
},
{
  "id": 495,
  "question": "Qual é o tamanho ideal de um pull request para review efetivo?",
  "options": [
    { "id": 1, "name": "Máximo de 400 linhas de código para manter foco e qualidade", "alias": "a" },
    { "id": 2, "name": "Não há limite, quanto maior melhor", "alias": "b" },
    { "id": 3, "name": "Apenas uma linha por pull request", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "PRs menores são mais fáceis de revisar, resultam em feedback melhor e reduzem erros.",
  "category": "code-review"
},
{
  "id": 496,
  "question": "O que é pair programming em relação ao code review?",
  "options": [
    { "id": 1, "name": "Dois desenvolvedores trabalhando juntos, eliminando necessidade de review posterior", "alias": "a" },
    { "id": 2, "name": "Revisar código em duplas após desenvolvimento", "alias": "b" },
    { "id": 3, "name": "Programar apenas em pares de arquivos", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Pair programming é review contínuo em tempo real, prevenindo problemas antes do commit.",
  "category": "code-review"
},
{
  "id": 497,
  "question": "Como lidar com conflitos durante code reviews?",
  "options": [
    { "id": 1, "name": "Discussão respeitosa focada no código, não na pessoa, com mediação se necessário", "alias": "a" },
    { "id": 2, "name": "Sempre aceitar a opinião do revisor mais sênior", "alias": "b" },
    { "id": 3, "name": "Evitar dar feedback para não criar conflitos", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Conflitos devem ser resolvidos através de discussão técnica construtiva e mediação quando necessário.",
  "category": "code-review"
},
{
  "id": 498,
  "question": "Qual é a importância do contexto em um pull request?",
  "options": [
    { "id": 1, "name": "Descrição clara do problema, solução e impacto facilita a revisão", "alias": "a" },
    { "id": 2, "name": "Contexto não é necessário se o código for claro", "alias": "b" },
    { "id": 3, "name": "Apenas o título do PR é suficiente", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Contexto bem documentado acelera o review e melhora a qualidade do feedback.",
  "category": "code-review"
},
{
  "id": 499,
  "question": "O que são automated code review tools?",
  "options": [
    { "id": 1, "name": "Ferramentas que analisam código automaticamente para detectar problemas", "alias": "a" },
    { "id": 2, "name": "Ferramentas para escrever código automaticamente", "alias": "b" },
    { "id": 3, "name": "Ferramentas para fazer deploy automático", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Tools como SonarQube, ESLint e CodeClimate automatizam detecção de code smells e vulnerabilidades.",
  "category": "code-review"
},
{
  "id": 500,
  "question": "Qual é o papel da documentação inline durante code review?",
  "options": [
    { "id": 1, "name": "Comentários que explicam lógica complexa facilitam a compreensão do revisor", "alias": "a" },
    { "id": 2, "name": "Documentação inline deve ser evitada sempre", "alias": "b" },
    { "id": 3, "name": "Apenas documenta bugs conhecidos", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Comentários bem colocados explicam o 'porquê' do código, não apenas o 'como'.",
  "category": "code-review"
},
{
  "id": 501,
  "question": "Como realizar code review de forma construtiva?",
  "options": [
    { "id": 1, "name": "Focar em melhorias, sugerir soluções e reconhecer bom trabalho", "alias": "a" },
    { "id": 2, "name": "Apenas apontar problemas sem sugestões", "alias": "b" },
    { "id": 3, "name": "Aprovar rapidamente para não atrasar o time", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Reviews construtivos educam, melhoram o código e mantêm o moral da equipe.",
  "category": "code-review"
},
{
  "id": 502,
  "question": "O que é mob programming em relação ao code review?",
  "options": [
    { "id": 1, "name": "Equipe inteira trabalhando no mesmo código simultaneamente", "alias": "a" },
    { "id": 2, "name": "Programação por criminosos", "alias": "b" },
    { "id": 3, "name": "Revisão de código por multidões", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Mob programming estende pair programming para toda a equipe, eliminando need de review posterior.",
  "category": "code-review"
},
{
  "id": 503,
  "question": "Qual é a importância da cobertura de testes durante code review?",
  "options": [
    { "id": 1, "name": "Verifica se novo código está adequadamente testado e não quebra testes existentes", "alias": "a" },
    { "id": 2, "name": "Testes não são necessários em code review", "alias": "b" },
    { "id": 3, "name": "Apenas verifica se os testes compilam", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Review deve verificar qualidade dos testes, cobertura de edge cases e manutenibilidade.",
  "category": "code-review"
},
{
  "id": 504,
  "question": "Como revisar código de diferentes níveis de senioridade?",
  "options": [
    { "id": 1, "name": "Adaptar abordagem: mentoring para juniores, colaboração para seniores", "alias": "a" },
    { "id": 2, "name": "Usar a mesma abordagem para todos", "alias": "b" },
    { "id": 3, "name": "Apenas seniores devem revisar código", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Reviews devem ser pedagógicos para juniores e colaborativos entre pares experientes.",
  "category": "code-review"
},
{
  "id": 505,
  "question": "O que são review checklists e quando usá-las?",
  "options": [
    { "id": 1, "name": "Listas padronizadas de itens a verificar durante a revisão", "alias": "a" },
    { "id": 2, "name": "Listas de tarefas do projeto", "alias": "b" },
    { "id": 3, "name": "Listas de bugs conhecidos", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Checklists garantem consistência e completude nas revisões, especialmente para equipes grandes.",
  "category": "code-review"
},
{
  "id": 506,
  "question": "Qual é o impacto cultural do code review em equipes de desenvolvimento?",
  "options": [
    { "id": 1, "name": "Promove colaboração, aprendizado mútuo e ownership coletivo do código", "alias": "a" },
    { "id": 2, "name": "Cria competição desnecessária entre desenvolvedores", "alias": "b" },
    { "id": 3, "name": "Não tem impacto na cultura da equipe", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Code review bem implementado fortalece a cultura de qualidade e colaboração na equipe.",
  "category": "code-review"
},
{
  "id": 507,
  "question": "Como balancear velocidade e qualidade em code reviews?",
  "options": [
    { "id": 1, "name": "Definir SLAs para review, priorizar mudanças críticas e usar automated checks", "alias": "a" },
    { "id": 2, "name": "Sempre priorizar velocidade sobre qualidade", "alias": "b" },
    { "id": 3, "name": "Revisar cada linha de código detalhadamente sempre", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Equilíbrio é alcançado com processos eficientes, automação e foco no que realmente importa.",
  "category": "code-review"
},
{
  "id": 508,
  "question": "Como criar um Design System eficiente no Figma?",
  "options": [
    { "id": 1, "name": "Usando components, variants, styles e design tokens organizados", "alias": "a" },
    { "id": 2, "name": "Copiando e colando elementos manualmente", "alias": "b" },
    { "id": 3, "name": "Criando arquivos separados para cada página", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Um Design System no Figma requer organização sistemática de components, variants e styles reutilizáveis.",
  "category": "figma"
},
{
  "id": 509,
  "question": "O que são Constraints no Figma e como usá-las?",
  "options": [
    { "id": 1, "name": "Regras que definem como elementos se comportam quando o frame é redimensionado", "alias": "a" },
    { "id": 2, "name": "Limitações de tamanho de arquivo", "alias": "b" },
    { "id": 3, "name": "Restrições de acesso ao projeto", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Constraints permitem criar layouts responsivos definindo como elementos se adaptam a mudanças de tamanho.",
  "category": "figma"
},
{
  "id": 510,
  "question": "Como otimizar a performance de arquivos grandes no Figma?",
  "options": [
    { "id": 1, "name": "Usando instances, otimizando imagens e organizando em páginas separadas", "alias": "a" },
    { "id": 2, "name": "Duplicando todos os componentes", "alias": "b" },
    { "id": 3, "name": "Mantendo tudo em uma única página", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Performance no Figma melhora com uso estratégico de instances, compressão de imagens e organização modular.",
  "category": "figma"
},
{
  "id": 511,
  "question": "O que é o recurso 'Smart Animate' no Figma?",
  "options": [
    { "id": 1, "name": "Transições automáticas entre frames baseadas em propriedades similares", "alias": "a" },
    { "id": 2, "name": "Animações de loading automáticas", "alias": "b" },
    { "id": 3, "name": "Redimensionamento inteligente de elementos", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Smart Animate cria transições fluidas detectando automaticamente elementos correspondentes entre frames.",
  "category": "figma"
},
{
  "id": 512,
  "question": "Como implementar Dark Mode em um Design System no Figma?",
  "options": [
    { "id": 1, "name": "Usando variables/tokens de cor e component variants", "alias": "a" },
    { "id": 2, "name": "Duplicando todos os components manualmente", "alias": "b" },
    { "id": 3, "name": "Criando arquivos separados para cada tema", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Dark Mode eficiente usa variables para cores e variants para alternar entre temas sem duplicação.",
  "category": "figma"
},
{
  "id": 513,
  "question": "O que são Figma Plugins e como podem acelerar o workflow?",
  "options": [
    { "id": 1, "name": "Extensões que automatizam tarefas repetitivas e integram ferramentas externas", "alias": "a" },
    { "id": 2, "name": "Componentes premium pagos", "alias": "b" },
    { "id": 3, "name": "Templates prontos para usar", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Plugins estendem funcionalidades do Figma automatizando tarefas como geração de conteúdo, exportação e integração com código.",
  "category": "figma"
},
{
  "id": 514,
  "question": "Como configurar um handoff eficiente para desenvolvedores no Figma?",
  "options": [
    { "id": 1, "name": "Usando mode 'Dev Mode', documentação clara e specs automatizadas", "alias": "a" },
    { "id": 2, "name": "Exportando tudo como imagens PNG", "alias": "b" },
    { "id": 3, "name": "Enviando screenshots por email", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Dev Mode no Figma fornece specs automáticas, assets otimizados e integração com ferramentas de desenvolvimento.",
  "category": "figma"
},
{
  "id": 515,
  "question": "O que são Figma Variables e como revolucionam Design Systems?",
  "options": [
    { "id": 1, "name": "Sistema de tokens que permite mudanças globais e temas dinâmicos", "alias": "a" },
    { "id": 2, "name": "Variáveis matemáticas para cálculos", "alias": "b" },
    { "id": 3, "name": "Elementos que mudam de cor aleatoriamente", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Variables permitem criar design tokens reutilizáveis que se propagam automaticamente por todo o design system.",
  "category": "figma"
},
{
  "id": 516,
  "question": "Como criar protótipos interativos avançados no Figma?",
  "options": [
    { "id": 1, "name": "Combinando interactions, overlays, smart animate e component states", "alias": "a" },
    { "id": 2, "name": "Apenas linkando frames com cliques simples", "alias": "b" },
    { "id": 3, "name": "Usando apenas hover effects", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Protótipos avançados usam múltiplas ferramentas de interação para simular experiências reais do usuário.",
  "category": "figma"
},
{
  "id": 517,
  "question": "O que é Boolean Operations no Figma?",
  "options": [
    { "id": 1, "name": "Operações para combinar, subtrair e interseccionar formas", "alias": "a" },
    { "id": 2, "name": "Operações lógicas true/false", "alias": "b" },
    { "id": 3, "name": "Configurações de privacidade", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Boolean Operations (Union, Subtract, Intersect, Exclude) permitem criar formas complexas combinando shapes básicas.",
  "category": "figma"
},
{
  "id": 518,
  "question": "Como versionar e gerenciar mudanças em projetos Figma grandes?",
  "options": [
    { "id": 1, "name": "Usando branching, version history e library publishing", "alias": "a" },
    { "id": 2, "name": "Salvando cópias locais manualmente", "alias": "b" },
    { "id": 3, "name": "Não é possível versionar no Figma", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Figma oferece ferramentas de versionamento profissional incluindo branches para trabalho paralelo e histórico detalhado.",
  "category": "figma"
},
{
  "id": 519,
  "question": "O que são Figma Libraries e como organizar assets reutilizáveis?",
  "options": [
    { "id": 1, "name": "Bibliotecas compartilhadas de components, styles e assets entre projetos", "alias": "a" },
    { "id": 2, "name": "Coleções de templates gratuitos", "alias": "b" },
    { "id": 3, "name": "Arquivos de backup automático", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Libraries permitem compartilhar e sincronizar components e styles entre múltiplos projetos da organização.",
  "category": "figma"
},
{
  "id": 520,
  "question": "Como implementar acessibilidade (A11y) no design usando Figma?",
  "options": [
    { "id": 1, "name": "Verificando contraste, usando plugins A11y e documentando estados de foco", "alias": "a" },
    { "id": 2, "name": "Apenas usando cores vibrantes", "alias": "b" },
    { "id": 3, "name": "Acessibilidade não é responsabilidade do design", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Design acessível no Figma requer atenção ao contraste, hierarquia clara e documentação de estados interativos.",
  "category": "figma"
},
{
  "id": 521,
  "question": "O que é Design Tokenization no contexto Figma?",
  "options": [
    { "id": 1, "name": "Processo de converter valores de design em tokens reutilizáveis e exportáveis", "alias": "a" },
    { "id": 2, "name": "Criptografia de arquivos de design", "alias": "b" },
    { "id": 3, "name": "Pagamento por uso de recursos premium", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Design tokens criam bridge entre design e código, exportando valores para uso direto no desenvolvimento.",
  "category": "figma"
},
{
  "id": 522,
  "question": "Como configurar um workflow colaborativo eficiente no Figma?",
  "options": [
    { "id": 1, "name": "Definindo permissões, comentários estruturados e processos de review", "alias": "a" },
    { "id": 2, "name": "Permitindo que todos editem tudo livremente", "alias": "b" },
    { "id": 3, "name": "Trabalhando apenas offline", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Colaboração eficiente requer estrutura: roles claros, processo de feedback organizado e versionamento disciplinado.",
  "category": "figma"
},
{
  "id": 523,
  "question": "O que é o princípio YAGNI (You Aren't Gonna Need It)?",
  "options": [
    { "id": 1, "name": "Não implementar funcionalidades até que sejam realmente necessárias", "alias": "a" },
    { "id": 2, "name": "Sempre implementar todas as funcionalidades possíveis antecipadamente", "alias": "b" },
    { "id": 3, "name": "Remover funcionalidades desnecessárias após implementação", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "YAGNI evita over-engineering focando apenas no que é necessário no momento presente.",
  "category": "boas-praticas"
},
{
  "id": 524,
  "question": "Qual é a importância do error handling adequado?",
  "options": [
    { "id": 1, "name": "Melhora experiência do usuário e facilita debugging em produção", "alias": "a" },
    { "id": 2, "name": "Não é necessário se o código estiver bem escrito", "alias": "b" },
    { "id": 3, "name": "Apenas esconde erros do usuário final", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Error handling robusto previne crashes, orienta usuários e fornece informações valiosas para desenvolvedores.",
  "category": "boas-praticas"
},
{
  "id": 525,
  "question": "O que são code smells e como identificá-los?",
  "options": [
    { "id": 1, "name": "Indicadores de possíveis problemas no código que sugerem necessidade de refatoração", "alias": "a" },
    { "id": 2, "name": "Erros de sintaxe que impedem compilação", "alias": "b" },
    { "id": 3, "name": "Comentários mal escritos no código", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Code smells como funções muito longas, duplicação excessiva e acoplamento forte indicam áreas para melhoria.",
  "category": "boas-praticas"
},
{
  "id": 526,
  "question": "Por que logging é uma boa prática essencial?",
  "options": [
    { "id": 1, "name": "Facilita debugging, monitoramento e auditoria de sistemas em produção", "alias": "a" },
    { "id": 2, "name": "Apenas para demonstrar que o código está executando", "alias": "b" },
    { "id": 3, "name": "Para substituir testes automatizados", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Logs estruturados são fundamentais para diagnosticar problemas, entender comportamento e garantir compliance.",
  "category": "boas-praticas"
},
{
  "id": 527,
  "question": "O que é defensive programming?",
  "options": [
    { "id": 1, "name": "Escrever código que funciona mesmo com inputs inesperados ou condições adversas", "alias": "a" },
    { "id": 2, "name": "Proteger código com senhas e criptografia", "alias": "b" },
    { "id": 3, "name": "Programar apenas funcionalidades defensivas", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Programming defensivo antecipa problemas usando validação de input, null checks e graceful degradation.",
  "category": "boas-praticas"
},
{
  "id": 528,
  "question": "Qual é a importância da consistência no estilo de código?",
  "options": [
    { "id": 1, "name": "Facilita leitura, manutenção e colaboração entre desenvolvedores", "alias": "a" },
    { "id": 2, "name": "Melhora performance do código", "alias": "b" },
    { "id": 3, "name": "Reduz o tamanho dos arquivos", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Código consistente reduz cognitive load e permite que qualquer dev do time entenda e modifique rapidamente.",
  "category": "boas-praticas"
},
{
  "id": 529,
  "question": "O que é pair programming e seus benefícios?",
  "options": [
    { "id": 1, "name": "Dois desenvolvedores trabalhando juntos no mesmo código simultaneamente", "alias": "a" },
    { "id": 2, "name": "Programar apenas em pares de funções", "alias": "b" },
    { "id": 3, "name": "Dividir tarefas igualmente entre dois desenvolvedores", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Pair programming melhora qualidade do código, acelera onboarding e promove knowledge sharing contínuo.",
  "category": "boas-praticas"
},
{
  "id": 530,
  "question": "Por que validação de input é crucial?",
  "options": [
    { "id": 1, "name": "Previne ataques de segurança, crashes e comportamentos inesperados", "alias": "a" },
    { "id": 2, "name": "Apenas melhora a aparência da interface", "alias": "b" },
    { "id": 3, "name": "Não é necessária em aplicações internas", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Input validation é primeira linha de defesa contra SQL injection, XSS e outros ataques maliciosos.",
  "category": "boas-praticas"
},
{
  "id": 531,
  "question": "O que é technical debt e como gerenciá-lo?",
  "options": [
    { "id": 1, "name": "Custo implícito de refatoração futura devido a soluções subótimas atuais", "alias": "a" },
    { "id": 2, "name": "Dívidas financeiras relacionadas a ferramentas de desenvolvimento", "alias": "b" },
    { "id": 3, "name": "Tempo gasto aprendendo novas tecnologias", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Technical debt deve ser monitorado e pago regularmente para evitar que comprometa velocidade de desenvolvimento futuro.",
  "category": "boas-praticas"
},
{
  "id": 532,
  "question": "Qual é a importância de code coverage em testes?",
  "options": [
    { "id": 1, "name": "Indica quanta parte do código é exercitada pelos testes", "alias": "a" },
    { "id": 2, "name": "Mede a velocidade de execução dos testes", "alias": "b" },
    { "id": 3, "name": "Define quantos testes são necessários", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Coverage revela áreas não testadas, mas 100% coverage não garante qualidade - foque em testes significativos.",
  "category": "boas-praticas"
},
{
  "id": 533,
  "question": "O que é continuous learning na carreira de desenvolvimento?",
  "options": [
    { "id": 1, "name": "Processo constante de atualização de conhecimentos e habilidades", "alias": "a" },
    { "id": 2, "name": "Aprender apenas quando mudando de emprego", "alias": "b" },
    { "id": 3, "name": "Estudar apenas tecnologias relacionadas ao projeto atual", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Tecnologia evolui rapidamente - desenvolvedores devem dedicar tempo regular para aprender e se adaptar.",
  "category": "boas-praticas"
},
{
  "id": 534,
  "question": "Por que performance optimization deve ser baseada em dados?",
  "options": [
    { "id": 1, "name": "Evita otimização prematura e foca nos gargalos reais", "alias": "a" },
    { "id": 2, "name": "Porque dados sempre mostram problemas de performance", "alias": "b" },
    { "id": 3, "name": "Para impressionar stakeholders com métricas", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Profile first, optimize second - métricas reais evitam desperdício de tempo em pseudo-otimizações.",
  "category": "boas-praticas"
},
{
  "id": 535,
  "question": "O que é mob programming e quando usar?",
  "options": [
    { "id": 1, "name": "Todo o time trabalhando no mesmo código simultaneamente", "alias": "a" },
    { "id": 2, "name": "Programação desenvolvida por multidões online", "alias": "b" },
    { "id": 3, "name": "Programação apenas para aplicações móveis", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Mob programming é eficaz para problemas complexos, knowledge transfer e decisões arquiteturais importantes.",
  "category": "boas-praticas"
},
{
  "id": 536,
  "question": "Qual é a importância da segurança by design?",
  "options": [
    { "id": 1, "name": "Integrar considerações de segurança desde o início do desenvolvimento", "alias": "a" },
    { "id": 2, "name": "Adicionar segurança apenas após completar todas as features", "alias": "b" },
    { "id": 3, "name": "Terceirizar toda responsabilidade de segurança", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Segurança como afterthought é cara e ineficaz - deve ser considerada em cada decisão de arquitetura.",
  "category": "boas-praticas"
},
{
  "id": 537,
  "question": "O que são design patterns e quando aplicá-los?",
  "options": [
    { "id": 1, "name": "Soluções reutilizáveis para problemas recorrentes de design de software", "alias": "a" },
    { "id": 2, "name": "Padrões visuais para interfaces de usuário", "alias": "b" },
    { "id": 3, "name": "Templates de código prontos para usar", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Design patterns como Singleton, Observer e Strategy devem ser aplicados quando o problema corresponde exatamente ao pattern.",
  "category": "boas-praticas"
},
{
  "id": 538,
  "question": "Por que é importante ter environment separation?",
  "options": [
    { "id": 1, "name": "Isola desenvolvimento, teste e produção para reduzir riscos", "alias": "a" },
    { "id": 2, "name": "Apenas para organizar melhor os arquivos", "alias": "b" },
    { "id": 3, "name": "Para economizar recursos de servidor", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Ambientes separados permitem desenvolvimento seguro, testes realistas e deployments controlados sem afetar produção.",
  "category": "boas-praticas"
},
{
  "id": 539,
  "question": "O que são Generics em TypeScript e quando usá-los?",
  "options": [
    { "id": 1, "name": "Permitem criar tipos flexíveis que trabalham com múltiplos tipos", "alias": "a" },
    { "id": 2, "name": "São tipos específicos para arrays", "alias": "b" },
    { "id": 3, "name": "Apenas uma forma de comentar código", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Generics como Array<T> ou Promise<T> permitem reutilização de código mantendo type safety.",
  "category": "typescript"
},
{
  "id": 540,
  "question": "Qual é a diferença entre 'any' e 'unknown' no TypeScript?",
  "options": [
    { "id": 1, "name": "'unknown' é type-safe e requer verificação antes do uso, 'any' desabilita verificações", "alias": "a" },
    { "id": 2, "name": "São exatamente iguais", "alias": "b" },
    { "id": 3, "name": "'any' é mais seguro que 'unknown'", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "unknown força verificação de tipo antes do uso, sendo uma alternativa mais segura ao any.",
  "category": "typescript"
},
{
  "id": 541,
  "question": "O que são mapped types em TypeScript?",
  "options": [
    { "id": 1, "name": "Tipos que criam novos tipos baseados em tipos existentes", "alias": "a" },
    { "id": 2, "name": "Tipos para trabalhar com mapas geográficos", "alias": "b" },
    { "id": 3, "name": "Tipos exclusivos para objetos Map", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Mapped types como Partial<T>, Required<T> transformam propriedades de tipos existentes.",
  "category": "typescript"
},
{
  "id": 542,
  "question": "O que são conditional types no TypeScript?",
  "options": [
    { "id": 1, "name": "Tipos que mudam baseados em condições usando sintaxe ternária", "alias": "a" },
    { "id": 2, "name": "Tipos que só funcionam com if/else", "alias": "b" },
    { "id": 3, "name": "Tipos exclusivos para promises", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Conditional types usam T extends U ? X : Y para criar tipos dinâmicos baseados em condições.",
  "category": "typescript"
},
{
  "id": 543,
  "question": "O que é template literal types no TypeScript?",
  "options": [
    { "id": 1, "name": "Tipos baseados em template literals que permitem patterns de string específicos", "alias": "a" },
    { "id": 2, "name": "Templates HTML dentro do TypeScript", "alias": "b" },
    { "id": 3, "name": "Apenas uma forma de comentar código", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Template literal types como `hello-${string}` criam tipos precisos para padrões de string.",
  "category": "typescript"
},
{
  "id": 544,
  "question": "Qual é o propósito do 'never' type no TypeScript?",
  "options": [
    { "id": 1, "name": "Representa valores que nunca devem ocorrer", "alias": "a" },
    { "id": 2, "name": "Um tipo para loops infinitos", "alias": "b" },
    { "id": 3, "name": "Equivalente ao tipo null", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "never é usado para funções que nunca retornam (throw error) ou para exhaustive checking.",
  "category": "typescript"
},
{
  "id": 545,
  "question": "O que são utility types no TypeScript?",
  "options": [
    { "id": 1, "name": "Tipos pré-definidos que facilitam transformações comuns", "alias": "a" },
    { "id": 2, "name": "Tipos para funções utilitárias apenas", "alias": "b" },
    { "id": 3, "name": "Tipos exclusivos para bibliotecas", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Utility types como Pick<T, K>, Omit<T, K>, Record<K, V> facilitam manipulação de tipos.",
  "category": "typescript"
},
{
  "id": 546,
  "question": "Como funciona type narrowing no TypeScript?",
  "options": [
    { "id": 1, "name": "Refina tipos através de checks condicionais como typeof, instanceof", "alias": "a" },
    { "id": 2, "name": "Reduz o tamanho dos tipos automaticamente", "alias": "b" },
    { "id": 3, "name": "Converte tipos complexos em tipos simples", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Type narrowing permite ao TypeScript inferir tipos mais específicos baseado em runtime checks.",
  "category": "typescript"
},
{
  "id": 547,
  "question": "O que são discriminated unions no TypeScript?",
  "options": [
    { "id": 1, "name": "Union types com propriedade comum que permite diferenciação", "alias": "a" },
    { "id": 2, "name": "União de tipos que só funciona com arrays", "alias": "b" },
    { "id": 3, "name": "Tipos que discriminam usuários", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Discriminated unions usam uma propriedade tag para type narrowing seguro em switch/if statements.",
  "category": "typescript"
},
{
  "id": 548,
  "question": "Qual é a diferença entre 'readonly' e 'const' no TypeScript?",
  "options": [
    { "id": 1, "name": "'readonly' é para propriedades de objetos/arrays, 'const' é para variáveis", "alias": "a" },
    { "id": 2, "name": "São exatamente iguais", "alias": "b" },
    { "id": 3, "name": "'const' é mais restritivo que 'readonly'", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "readonly previne modificação de propriedades após inicialização, const previne reassignment de variáveis.",
  "category": "typescript"
},
{
  "id": 549,
  "question": "O que é index signature no TypeScript?",
  "options": [
    { "id": 1, "name": "Define o tipo para propriedades dinâmicas de um objeto", "alias": "a" },
    { "id": 2, "name": "Assinatura digital para arquivos TypeScript", "alias": "b" },
    { "id": 3, "name": "Índice de todas as funções do projeto", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Index signature como [key: string]: any permite propriedades dinâmicas com tipos específicos.",
  "category": "typescript"
},
{
  "id": 550,
  "question": "Como usar keyof operator no TypeScript?",
  "options": [
    { "id": 1, "name": "Obtém união de todas as chaves de um tipo de objeto", "alias": "a" },
    { "id": 2, "name": "Verifica se uma chave existe em um objeto", "alias": "b" },
    { "id": 3, "name": "Remove chaves de um tipo", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "keyof T produz união literal das chaves de T, útil para type-safe property access.",
  "category": "typescript"
},
{
  "id": 551,
  "question": "O que são function overloads no TypeScript?",
  "options": [
    { "id": 1, "name": "Múltiplas assinaturas para a mesma função com diferentes parâmetros", "alias": "a" },
    { "id": 2, "name": "Funções que executam outras funções", "alias": "b" },
    { "id": 3, "name": "Funções que fazem muitas operações", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Function overloads permitem diferentes assinaturas para a mesma função baseadas nos tipos de entrada.",
  "category": "typescript"
},
{
  "id": 552,
  "question": "O que é module augmentation no TypeScript?",
  "options": [
    { "id": 1, "name": "Extensão de módulos existentes com novos tipos ou propriedades", "alias": "a" },
    { "id": 2, "name": "Aumento do tamanho dos módulos", "alias": "b" },
    { "id": 3, "name": "Duplicação de módulos para backup", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Module augmentation permite adicionar tipos a módulos externos como libraries npm.",
  "category": "typescript"
},
{
  "id": 553,
  "question": "Como funciona o sistema de modules no TypeScript?",
  "options": [
    { "id": 1, "name": "Suporta ES modules, CommonJS e AMD com interoperabilidade", "alias": "a" },
    { "id": 2, "name": "Apenas suporta ES modules", "alias": "b" },
    { "id": 3, "name": "Não suporta sistema de módulos", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "TypeScript compila para diferentes sistemas de módulos mantendo type safety entre boundaries.",
  "category": "typescript"
},
{
  "id": 554,
  "question": "O que são decorators no TypeScript?",
  "options": [
    { "id": 1, "name": "Metaprogramação que permite modificar classes, métodos e propriedades", "alias": "a" },
    { "id": 2, "name": "Apenas comentários decorativos", "alias": "b" },
    { "id": 3, "name": "Padrões de design visual", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Decorators como @Component no Angular usam metaprogramação para adicionar funcionalidades declarativamente.",
  "category": "typescript"
},
{
  "id": 555,
  "question": "Qual é o propósito do strict mode no TypeScript?",
  "options": [
    { "id": 1, "name": "Habilita verificações de tipo mais rigorosas para maior segurança", "alias": "a" },
    { "id": 2, "name": "Desabilita todas as verificações de tipo", "alias": "b" },
    { "id": 3, "name": "Apenas para projetos em produção", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Strict mode ativa flags como strictNullChecks, noImplicitAny para maximum type safety.",
  "category": "typescript"
},
{
  "id": 556,
  "question": "Como configurar path mapping no TypeScript?",
  "options": [
    { "id": 1, "name": "Usando 'paths' no tsconfig.json para criar aliases de importação", "alias": "a" },
    { "id": 2, "name": "Modificando variáveis de ambiente do sistema", "alias": "b" },
    { "id": 3, "name": "Não é possível configurar path mapping", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Path mapping permite imports limpos como @/components em vez de ../../../components.",
  "category": "typescript"
},
{
  "id": 557,
  "question": "O que é declaration merging no TypeScript?",
  "options": [
    { "id": 1, "name": "Capacidade de combinar múltiplas declarações do mesmo nome", "alias": "a" },
    { "id": 2, "name": "Fusão de arquivos .d.ts automaticamente", "alias": "b" },
    { "id": 3, "name": "Combinação de tipos primitivos", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Declaration merging permite estender interfaces, namespaces e enums definidos em locais diferentes.",
  "category": "typescript"
},
{
  "id": 558,
  "question": "Como otimizar performance de compilação TypeScript em projetos grandes?",
  "options": [
    { "id": 1, "name": "Usando project references, incremental compilation e skipLibCheck", "alias": "a" },
    { "id": 2, "name": "Removendo todos os tipos para compilar mais rápido", "alias": "b" },
    { "id": 3, "name": "Compilando apenas arquivos modificados manualmente", "alias": "c" }
  ],
  "correct": "a",
  "explanation": "Project references e incremental builds aceleram drasticamente compilação em monorepos e projetos grandes.",
  "category": "typescript"
}

  ],
  "results": {
    "X": "Parabéns! Você possui muito conhecimento em front-end!",
    "Y": "Continue estudando para melhorar suas habilidades!"
  }
}
